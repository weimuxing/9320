/*
   $Workfile:   osd_factory.c  $
   $Revision: 1.92 $
   $Date: 2013/04/08 02:01:38 $
*/
#define __OSD_FACTORY_C__
//******************************************************************************
// COPYRIGHT (C) STMicroelectronics 2011.
//
// All rights reserved. This document contains proprietary and
// confidential information of the STMicroelectronics Group. This
// document is not to be copied in whole or part. STMicroelectronics
// assumes no responsibility for the consequences of use of such
// information nor for any infringement of patents or other rights of
// third parties which may result from its use. No license is granted by
// implication or otherwise under any patent or patent rights of
// STMicroelectronics.
// STMicroelectronics
// products are not authorized for use as critical components in life
// support devices or systems without express written approval of
// STMicroelectronics.
//==============================================================================
//
// MODULE:      osd_factory.c
//
// USAGE:      This module contains standard osd adjusters for the factory menu
//
//******************************************************************************

//******************************************************************************
//  I N C L U D E    F I L E S
//******************************************************************************

#include "System\All.h"
#include "StdLibInc\gm_Register.h"
#include "StdLibInc\gm_ACM3D.h"
#include "mem.h"

//******************************************************************************
//  D E F I N E S
//******************************************************************************

#define   IMP_VLUT_SIZE 1024 /*number of IMP VLUT entries*/
#define   IMP_VLUT_WIDTH sizeof(WORD) /*number of bytes in eac IMP VLUT entry*/
//#define _DEBUG
#ifdef _DEBUG
#define  msg(a)            gm_Print(a, 0)
#define  msg_i(a, b)      gm_Print(a, b)
#else
#define  msg(a)
#define  msg_i(a, b)
#endif

#define BIT0_TO_BIT9   0x03FF
#define BIT0_TO_BIT5   0x003F
#define BIT0_TO_BIT11   0x0FFF


extern PortSchemeDependentUserPrefType ROM SchemeFactoryDefaultInROM[NUM_IMAGE_SCHEMES]; // PSD
#if USE_NEW_GAMMA
extern gmt_GammaDescr ROM * ROM Sta_GammaLUT_ColorSpace;//120809 Edward for gamma
#endif

#ifdef GammaData_To_DDR
static GammaData_Structure Gamma_RAM *GammaLUT_sRGB;
static GammaData_Structure Gamma_RAM *GammaLUT_AdobeRGB;

static GammaData_Structure Gamma_RAM *ptr_GammaLUTInRAM;

static BYTE Gamma_RAM GammaDataInRAM[sizeof(GammaData_Structure)*2];

#define Gamma_Loaded_Flag		0x5A
#define GammaLUT_sRGB       	(GammaData_Structure far *)(GammaDataInRAM)
#define GammaLUT_AdobeRGB   	(GammaData_Structure far *)(GammaDataInRAM + sizeof(GammaData_Structure))

#define ptr_GammaLUTInRAM		((UserPrefPresetColorSpace == CSPACE_sRGB)?(GammaLUT_sRGB):\
								((UserPrefPresetColorSpace == CSPACE_AdobeRGB)?(GammaLUT_AdobeRGB):(NULL_PTR)))
#endif


#define INPUT_GAMMA_R_MEM_START 0x1C000L
#define INPUT_GAMMA_R_STEEP_MEM_START 0x1C400L
#define INPUT_GAMMA_G_MEM_START 0x1C800L
#define INPUT_GAMMA_G_STEEP_MEM_START 0x1CC00L
#define INPUT_GAMMA_B_MEM_START 0x1D000L
#define INPUT_GAMMA_B_STEEP_MEM_START 0x1D400L

#ifdef USE_GAMMMA_TABLE_FROM_NVRAM
#define OUTPUT_GAMMA_R_MEM_START 0x1D800L
#define OUTPUT_GAMMA_R_STEEP_MEM_START 0x1DC00L
#define OUTPUT_GAMMA_G_MEM_START 0x1E000L
#define OUTPUT_GAMMA_G_STEEP_MEM_START 0x1E400L
#define OUTPUT_GAMMA_B_MEM_START 0x1E800L
#define OUTPUT_GAMMA_B_STEEP_MEM_START 0x1EC00L
#endif

#if (FEATURE_DITHER == ENABLE)
extern void Dither_UploadDitherTable(void);
#endif

#if 0
#pragma warn -sig // BIT15 Causes "Conversion may lose significant digits" warning because we are using the sign bit
WORD const PreLUT_xvYCC[512]=
{
   0, 43346, 42250, 37930, 660, 41298, 34058, 5160, 1304, 41266,
   34057, 37926, 1932, 39218, 25865, 37670, 2544, 39202, 25801, 4900,
   3140, 37170, 17545, 4644, 3720, 37154, 17544, 37410, 4288, 35106,
   9289, 4386, 4840, 35090, 1096, 37152, 5376, 33042, 1096, 4128,
   5896, 33026, 1032, 4126, 6404, 30977, 58375, 36640, 6896, 30961,
   58311, 36636, 7372, 30945, 58247, 36382, 7836, 28897, 50055, 3612,
   8284, 28881, 50054, 36378, 8716, 28881, 41798, 36122, 9136, 26833,
   41734, 35866, 9540, 26817, 33606, 3096, 9932, 24769, 33541, 35864,
   10308, 24753, 33477, 35862, 10672, 22705, 25285, 35606, 11020, 22705,
   17093, 2582, 11356, 20657, 17029, 2580, 11680, 18593, 16965, 2578,
   11984, 20625, 8836, 35090, 12280, 18577, 8772, 2322, 12560, 18561,
   8708, 34832, 12828, 18561, 516, 1808, 13084, 16497, 515, 34830,
   13328, 14448, 57859, 34574, 13556, 14448, 49603, 34572, 13772, 12400,
   49603, 1548, 13976, 12384, 49539, 1548, 14164, 12384, 49475, 1292,
   14344, 12368, 41283, 1290, 14512, 10320, 41218, 34058, 14664, 10320,
   33090, 1034, 14808, 8272, 33026, 1032, 14940, 8256, 24834, 1030,
   15060, 6208, 24833, 33544, 15168, 6192, 24769, 33798, 15268, 6192,
   32961, 33542, 15372, 6192, 24770, 774, 15472, 6208, 24769, 33544,
   15576, 6192, 24833, 33542, 15676, 8240, 24769, 33798, 15780, 6192,
   32961, 33542, 15884, 6192, 24770, 774, 15984, 6208, 24769, 33544,
   16088, 6192, 24833, 33542, 16188, 8224, 32961, 33544, 16292, 8240,
   32962, 1032, 16408, 8256, 33026, 1032, 16536, 10304, 33026, 33802,
   16676, 10304, 41282, 33802, 16828, 10320, 41282, 34060, 16992, 10336,
   41283, 1292, 17168, 10336, 49539, 1548, 17356, 12384, 49539, 1804,
   17556, 12400, 49603, 1806, 17768, 14448, 49604, 1806, 17992, 14464,
   57796, 1808, 18232, 14465, 515, 34832, 18480, 16529, 516, 2320,
   18744, 18561, 8772, 2322, 19024, 18577, 8772, 35090, 19312, 20625,
   16965, 2324, 19620, 18593, 17029, 2580, 19936, 20641, 25221, 2836,
   20268, 20657, 25221, 35606, 20612, 22705, 25286, 2838, 20972, 22721,
   25350, 2840, 21344, 24769, 33542, 3096, 21732, 24769, 41734, 36120,
   22132, 26833, 41734, 36378, 22548, 26833, 49991, 3356, 22976, 28897,
   41863, 3612, 23420, 28913, 50055, 3868, 23880, 28913, 58311, 3870,
   24352, 30961, 58375, 36640, 24840, 33010, 968, 4128, 25344, 33026,
   1032, 4130, 25860, 35074, 9224, 37152, 26392, 35090, 9288, 37156,
   26940, 35106, 9352, 37412, 27500, 37154, 17545, 4646, 28080, 37170,
   17545, 37668, 28672, 39218, 25737, 37926, 29280, 39234, 25802, 4904,
   29904, 39234, 34058, 5160, 30540, 43330, 34122, 5416, 31196, 43330,
   42314, 38186, 31864, 43362, 42315, 5420, 32552, 43362, 50571, 5676,
   33252, 45410, 50635, 5932, 33968, 47458, 58827, 38702, 34700, 47475,
   1483, 38958, 35448, 49523, 1548, 6192, 36212, 49539, 9740, 6448,
   36992, 51587, 9804, 39218, 37788, 51603, 17997, 6452, 38600, 53667,
   9869, 6708, 39428, 53683, 18061, 39478, 40272, 55731, 26253, 39734,
   41136, 55731, 26381, 39990, 42012, 57779, 34574, 7224, 42904, 59843,
   34638, 7480, 43816, 59843, 42830, 40250, 44740, 61907, 42894, 40506,
   45684, 61923, 51087, 7740, 46644, 61939, 51151, 7996, 47620, 63987,
   59343, 40766, 48613, 500, 2000, 8000, 49625, 516, 2064, 8256,
   50649, 2564, 10256, 41280, 51693, 2580, 10320, 41538, 52753, 4628,
   18576, 41540, 53833, 4644, 18577, 8774, 54925, 6692, 26833, 9030,
   56037, 6708, 26897, 41800, 57165, 8756, 35090, 9288, 58313, 8772,
   35090, 42058, 59473, 10836, 35154, 42314, 60653, 10852, 43347, 9548,
   61853, 10852, 51603, 9804, 63065, 12916, 51667, 10060, 64297, 14964,
   59859, 42830
}; //Size = 512, number of gamma entries = 1024

BYTE const LUT_1[1024]=
{
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x00,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x02,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x04,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x06,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x08,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x10,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x12,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x14,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x16,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x18,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x20,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x22,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x24,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x26,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x28,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x30,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x32,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x34,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x36,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x38,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x40,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x42,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x44,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x46,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x48,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x50,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x52,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x54,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x56,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x58,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x60,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x62,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x64,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x66,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x68,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x70,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x72,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x74,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x76,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x78,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x80,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x82,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x84,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x86,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x88,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x90,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x92,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x94,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x96,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x98,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFE,

};

#if 1
WORD const PreLUT_2_2_Tool[]=
{
   0, 0, 0, 0, 0, 64, 0, 0, 32768, 0,
   2048, 4, 256, 64, 16, 16, 32770, 64, 16, 32,
   32770, 8256, 16, 52, 33026, 8256, 2064, 76, 33026, 8320,
   2064, 108, 33028, 8320, 4112, 144, 260, 16449, 4112, 188,
   516, 16449, 2080, 240, 516, 16513, 4112, 296, 516, 24705,
   4128, 356, 772, 16577, 4128, 428, 772, 16577, 4144, 504,
   33542, 16577, 6192, 584, 33544, 24769, 4144, 676, 774, 24770,
   6192, 772, 776, 32962, 8240, 872, 33800, 33025, 8240, 984,
   1032, 33026, 6208, 1104, 1034, 33026, 8256, 1228, 33800, 33026,
   8272, 1360, 33802, 41218, 8272, 1500, 34058, 41282, 8272, 1648,
   34058, 41346, 10320, 1800, 34314, 41282, 10336, 1964, 34314, 41346,
   10336, 2136, 1548, 41347, 12384, 2312, 1548, 49603, 10336, 2500,
   1804, 57731, 12384, 2692, 34318, 57731, 14432, 2892, 1806, 57795,
   12400, 3104, 34574, 57795, 14448, 3320, 1806, 57796, 16496, 3544,
   34832, 57859, 14464, 3780, 2064, 57860, 16512, 4020, 2064, 516,
   16513, 4272, 34832, 516, 16529, 4528, 34834, 580, 16529, 4796,
   34834, 8772, 16529, 5072, 35090, 8836, 18577, 5352, 2324, 8773,
   18593, 5644, 35348, 17028, 20625, 5944, 2580, 17029, 20641, 6252,
   2582, 17029, 20641, 6572, 35350, 17029, 20657, 6896, 35604, 17093,
   20657, 7232, 35606, 25285, 22705, 7572, 35608, 33477, 22705, 7924,
   2840, 25350, 24753, 8284, 3096, 33478, 24769, 8652, 3096, 33542,
   24769, 9032, 3098, 33606, 26817, 9416, 3354, 41798, 26817, 9812,
   36122, 41798, 26833, 10216, 36378, 41798, 26833, 10632, 36378, 41862,
   28881, 11052, 3356, 50055, 28881, 11484, 3612, 50055, 28897, 11924,
   36382, 50055, 30945, 12372, 36382, 58247, 28913, 12832, 36638, 58311,
   30945, 13300, 3870, 58312, 30961, 13776, 36896, 967, 33010, 14260,
   3872, 1032, 33010, 14756, 4128, 1032, 33026, 15260, 4130, 1096,
   35074, 15772, 37152, 9224, 35074, 16296, 4386, 9288, 35090, 16828,
   37156, 9288, 37138, 17368, 37412, 9352, 35106, 17920, 4644, 9353,
   37154, 18480, 4644, 17609, 37154, 19048, 37414, 17545, 37170, 19628,
   4902, 25801, 39202, 20216, 37670, 25801, 39202, 20816, 4902, 25802,
   39218, 21424, 37928, 25865, 39234, 22040, 4904, 34058, 41282, 22664,
   5162, 34058, 41298, 23300, 37930, 34058, 41298, 23948, 38186, 42250,
   41298, 24604, 38186, 42314, 43346, 25268, 38442, 42378, 43346, 25944,
   5674, 42379, 43362, 26628, 5676, 50571, 45410, 27320, 5932, 58763,
   45410, 28024, 5934, 58827, 45410, 28740, 38702, 58827, 47474, 29460,
   38958, 58827, 47474, 30196, 5936, 1484, 49523, 30936, 5936, 1548,
   47491, 31692, 6192, 9740, 49539, 32452, 38962, 9740, 49539, 33228,
   39216, 9804, 51587, 34008, 39474, 9804, 51603, 34800, 6452, 9805,
   51619, 35604, 39476, 18060, 53651, 36416, 6708, 18061, 53667, 37240,
   6964, 26253, 53667, 38072, 6966, 18125, 53683, 38916, 39734, 26317,
   55715, 39768, 6966, 26318, 57779, 40628, 39992, 26381, 55747, 41504,
   7224, 34574, 57795, 42384, 39992, 34574, 57795, 43280, 40248, 42766,
   57795, 44184, 40250, 42830, 59843, 45096, 7482, 42831, 59859, 46020,
   7484, 51023, 61907, 46952, 7740, 51023, 61923, 47896, 40508, 51087,
   61923, 48852, 7996, 51151, 63971, 49816, 40764, 59343, 63971, 50792,
   40766, 59407, 63987, 51776, 41022, 59407, 499, 52773, 41024, 2063,
   64004, 53780, 8256, 2064, 516, 54797, 8512, 10256, 516, 55825,
   8514, 10320, 2564, 56861, 41282, 10320, 2580, 57909, 41538, 10384,
   4628, 58965, 8770, 10385, 2596, 60037, 8772, 18577, 4644, 61113,
   9028, 26769, 4644, 62205, 41796, 26769, 4660, 63305, 41798, 26833,
   6708, 64413
}; //Size = 512, number of gamma entries = 1024



BYTE const PreLUT_2_2[1024]=
{
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x00,
   0x00,
   0x10,
   0x00,
   0x04,
   0x00,
   0x02,
   0x80,
   0x00,
   0x00,
   0x10,
   0x00,
   0x10,
   0x00,
   0x02,
   0x80,
   0x40,
   0x00,
   0x10,
   0x08,
   0x1C,
   0x00,
   0x02,
   0x01,
   0x40,
   0x20,
   0x10,
   0x00,
   0x34,
   0x00,
   0x02,
   0x81,
   0x40,
   0x20,
   0x10,
   0x08,
   0x4C,
   0x00,
   0x02,
   0x01,
   0x41,
   0x20,
   0x10,
   0x08,
   0x6C,
   0x00,
   0x04,
   0x81,
   0x80,
   0x20,
   0x10,
   0x10,
   0x90,
   0x00,
   0x04,
   0x01,
   0x41,
   0x40,
   0x10,
   0x10,
   0xBC,
   0x00,
   0x04,
   0x02,
   0x41,
   0x40,
   0x20,
   0x08,
   0xF0,
   0x00,
   0x04,
   0x02,
   0x81,
   0x40,
   0x20,
   0x08,
   0x28,
   0x01,
   0x04,
   0x02,
   0xC1,
   0x40,
   0x20,
   0x10,
   0x64,
   0x01,
   0x04,
   0x03,
   0xC1,
   0x40,
   0x20,
   0x18,
   0xA8,
   0x01,
   0x04,
   0x03,
   0xC1,
   0x60,
   0x20,
   0x18,
   0xF4,
   0x01,
   0x06,
   0x83,
   0xC1,
   0x60,
   0x20,
   0x18,
   0x48,
   0x02,
   0x06,
   0x83,
   0xC1,
   0x60,
   0x30,
   0x18,
   0xA0,
   0x02,
   0x06,
   0x84,
   0xC1,
   0x60,
   0x30,
   0x20,
   0x00,
   0x03,
   0x06,
   0x84,
   0xC1,
   0x80,
   0x30,
   0x20,
   0x68,
   0x03,
   0x08,
   0x04,
   0xC2,
   0x80,
   0x30,
   0x20,
   0xD8,
   0x03,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0x20,
   0x4C,
   0x04,
   0x0A,
   0x04,
   0x02,
   0x81,
   0x40,
   0x20,
   0xCC,
   0x04,
   0x08,
   0x05,
   0x02,
   0xA1,
   0x40,
   0x20,
   0x50,
   0x05,
   0x0A,
   0x84,
   0x42,
   0x81,
   0x50,
   0x20,
   0xDC,
   0x05,
   0x0A,
   0x84,
   0x42,
   0xA1,
   0x50,
   0x20,
   0x70,
   0x06,
   0x0A,
   0x05,
   0x43,
   0xA1,
   0x50,
   0x28,
   0x08,
   0x07,
   0x0A,
   0x86,
   0x42,
   0xC1,
   0x50,
   0x28,
   0xAC,
   0x07,
   0x0A,
   0x86,
   0x82,
   0xC1,
   0x50,
   0x28,
   0x58,
   0x08,
   0x0C,
   0x06,
   0x83,
   0xC1,
   0x50,
   0x30,
   0x08,
   0x09,
   0x0C,
   0x07,
   0x83,
   0xC1,
   0x60,
   0x30,
   0xC0,
   0x09,
   0x0E,
   0x06,
   0xC3,
   0xC1,
   0x60,
   0x30,
   0x84,
   0x0A,
   0x0E,
   0x86,
   0x83,
   0xE1,
   0x60,
   0x38,
   0x4C,
   0x0B,
   0x0E,
   0x87,
   0x83,
   0xE1,
   0x70,
   0x30,
   0x20,
   0x0C,
   0x0E,
   0x87,
   0xC3,
   0xE1,
   0x70,
   0x38,
   0xF8,
   0x0C,
   0x0E,
   0x07,
   0xC4,
   0xE1,
   0x80,
   0x38,
   0xD8,
   0x0D,
   0x0E,
   0x88,
   0x03,
   0xE2,
   0x80,
   0x38,
   0xC4,
   0x0E,
   0x10,
   0x08,
   0x04,
   0xE2,
   0x80,
   0x40,
   0xB4,
   0x0F,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0xB0,
   0x10,
   0x10,
   0x88,
   0x04,
   0x02,
   0x91,
   0x40,
   0xB0,
   0x11,
   0x12,
   0x09,
   0x44,
   0x02,
   0x91,
   0x40,
   0xBC,
   0x12,
   0x12,
   0x09,
   0x44,
   0x22,
   0x91,
   0x48,
   0xCC,
   0x13,
   0x12,
   0x09,
   0x45,
   0x22,
   0x91,
   0x48,
   0xE8,
   0x14,
   0x14,
   0x09,
   0x45,
   0x22,
   0xA1,
   0x48,
   0x0C,
   0x16,
   0x12,
   0x0A,
   0x45,
   0x42,
   0x91,
   0x50,
   0x38,
   0x17,
   0x14,
   0x8A,
   0x84,
   0x42,
   0xA1,
   0x50,
   0x6C,
   0x18,
   0x16,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x58,
   0xA8,
   0x19,
   0x16,
   0x8A,
   0x85,
   0x42,
   0xB1,
   0x50,
   0xF0,
   0x1A,
   0x16,
   0x8A,
   0xC5,
   0x42,
   0xB1,
   0x58,
   0x3C,
   0x1C,
   0x16,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0x58,
   0x94,
   0x1D,
   0x18,
   0x8B,
   0x05,
   0x63,
   0xB1,
   0x58,
   0xF4,
   0x1E,
   0x18,
   0x8C,
   0x05,
   0x63,
   0xC1,
   0x58,
   0x5C,
   0x20,
   0x18,
   0x0C,
   0x06,
   0x63,
   0xC1,
   0x60,
   0xCC,
   0x21,
   0x18,
   0x0C,
   0x06,
   0x83,
   0xC1,
   0x60,
   0x48,
   0x23,
   0x1A,
   0x0C,
   0x46,
   0x83,
   0xC1,
   0x68,
   0xC8,
   0x24,
   0x1A,
   0x8D,
   0x06,
   0xA3,
   0xC1,
   0x68,
   0x54,
   0x26,
   0x1A,
   0x8D,
   0x46,
   0xA3,
   0xD1,
   0x68,
   0xE8,
   0x27,
   0x1A,
   0x8E,
   0x46,
   0xA3,
   0xD1,
   0x68,
   0x88,
   0x29,
   0x1A,
   0x8E,
   0x86,
   0xA3,
   0xE1,
   0x68,
   0x2C,
   0x2B,
   0x1C,
   0x8E,
   0x86,
   0xC3,
   0xD1,
   0x70,
   0xDC,
   0x2C,
   0x1C,
   0x0E,
   0x87,
   0xC3,
   0xE1,
   0x70,
   0x94,
   0x2E,
   0x1C,
   0x8E,
   0x87,
   0xC3,
   0xF1,
   0x70,
   0x54,
   0x30,
   0x1E,
   0x8E,
   0xC7,
   0xC3,
   0xF1,
   0x70,
   0x20,
   0x32,
   0x1E,
   0x8F,
   0xC7,
   0xE3,
   0xF1,
   0x70,
   0xF4,
   0x33,
   0x1E,
   0x90,
   0xC7,
   0xE3,
   0xF1,
   0x78,
   0xD0,
   0x35,
   0x1E,
   0x90,
   0x07,
   0xE4,
   0xF1,
   0x80,
   0xB4,
   0x37,
   0x20,
   0x90,
   0x07,
   0x04,
   0xF2,
   0x80,
   0xA4,
   0x39,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x9C,
   0x3B,
   0x22,
   0x90,
   0x08,
   0x04,
   0x02,
   0x89,
   0x9C,
   0x3D,
   0x20,
   0x91,
   0x08,
   0x24,
   0x02,
   0x89,
   0xA8,
   0x3F,
   0x22,
   0x91,
   0x48,
   0x04,
   0x12,
   0x89,
   0xBC,
   0x41,
   0x24,
   0x91,
   0x48,
   0x24,
   0x22,
   0x89,
   0xD8,
   0x43,
   0x22,
   0x92,
   0x88,
   0x24,
   0x22,
   0x89,
   0x00,
   0x46,
   0x22,
   0x12,
   0x89,
   0x44,
   0x12,
   0x91,
   0x30,
   0x48,
   0x24,
   0x92,
   0x89,
   0x44,
   0x22,
   0x91,
   0x68,
   0x4A,
   0x26,
   0x92,
   0x89,
   0x44,
   0x32,
   0x91,
   0xAC,
   0x4C,
   0x26,
   0x13,
   0xC9,
   0x64,
   0x22,
   0x99,
   0xF8,
   0x4E,
   0x26,
   0x93,
   0xC9,
   0x64,
   0x32,
   0x91,
   0x50,
   0x51,
   0x26,
   0x13,
   0xCA,
   0x64,
   0x32,
   0xA1,
   0xAC,
   0x53,
   0x28,
   0x94,
   0x09,
   0x65,
   0x42,
   0x99,
   0x18,
   0x56,
   0x28,
   0x94,
   0x09,
   0x85,
   0x42,
   0xA1,
   0x88,
   0x58,
   0x28,
   0x14,
   0x0A,
   0xA5,
   0x42,
   0xA1,
   0x04,
   0x5B,
   0x2A,
   0x94,
   0x0A,
   0xA5,
   0x42,
   0xA1,
   0x8C,
   0x5D,
   0x2A,
   0x95,
   0x0A,
   0xA5,
   0x52,
   0xA1,
   0x1C,
   0x60,
   0x2A,
   0x95,
   0x4A,
   0xA5,
   0x52,
   0xA9,
   0xB4,
   0x62,
   0x2A,
   0x96,
   0x8A,
   0xA5,
   0x52,
   0xB1,
   0x54,
   0x65,
   0x2C,
   0x15,
   0x8B,
   0xA5,
   0x62,
   0xA9,
   0x04,
   0x68,
   0x2C,
   0x16,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0xB8,
   0x6A,
   0x2C,
   0x17,
   0x8B,
   0xE5,
   0x62,
   0xB1,
   0x78,
   0x6D,
   0x2C,
   0x17,
   0xCB,
   0xE5,
   0x62,
   0xB9,
   0x40,
   0x70,
   0x2E,
   0x96,
   0xCB,
   0xE5,
   0x72,
   0xB9,
   0x14,
   0x73,
   0x2E,
   0x98,
   0xCB,
   0xE5,
   0x72,
   0xB9,
   0xF4,
   0x75,
   0x30,
   0x17,
   0xCC,
   0x05,
   0x73,
   0xC1,
   0xD8,
   0x78,
   0x30,
   0x98,
   0x0B,
   0x06,
   0x83,
   0xB9,
   0xCC,
   0x7B,
   0x30,
   0x18,
   0x4C,
   0x06,
   0x83,
   0xC1,
   0xC4,
   0x7E,
   0x30,
   0x19,
   0x4C,
   0x06,
   0x83,
   0xC9,
   0xC8,
   0x81,
   0x32,
   0x98,
   0x4C,
   0x26,
   0x83,
   0xC9,
   0xD8,
   0x84,
   0x34,
   0x99,
   0x4C,
   0x26,
   0x93,
   0xC9,
   0xF0,
   0x87,
   0x32,
   0x19,
   0x4D,
   0x46,
   0x93,
   0xC9,
   0x14,
   0x8B,
   0x34,
   0x1A,
   0x4D,
   0x46,
   0x93,
   0xD1,
   0x40,
   0x8E,
   0x36,
   0x1A,
   0x8D,
   0x46,
   0x93,
   0xD1,
   0x78,
   0x91,
   0x34,
   0x1B,
   0xCD,
   0x46,
   0xA3,
   0xD1,
   0xB8,
   0x94,
   0x36,
   0x1B,
   0xCD,
   0x66,
   0xA3,
   0xD9,
   0x00,
   0x98,
   0x36,
   0x9B,
   0xCD,
   0x66,
   0xB3,
   0xD1,
   0x58,
   0x9B,
   0x36,
   0x9C,
   0xCD,
   0x66,
   0xC3,
   0xD9,
   0xB4,
   0x9E,
   0x38,
   0x9C,
   0x0D,
   0x87,
   0xB3,
   0xD9,
   0x20,
   0xA2,
   0x38,
   0x1C,
   0x0E,
   0x87,
   0xC3,
   0xE1,
   0x90,
   0xA5,
   0x38,
   0x1D,
   0x0E,
   0x87,
   0xC3,
   0xE1,
   0x10,
   0xA9,
   0x3A,
   0x9C,
   0x0E,
   0xA7,
   0xC3,
   0xE9,
   0x94,
   0xAC,
   0x3A,
   0x9D,
   0x4E,
   0xA7,
   0xC3,
   0xE9,
   0x28,
   0xB0,
   0x3A,
   0x9E,
   0x4E,
   0xA7,
   0xD3,
   0xE9,
   0xC4,
   0xB3,
   0x3C,
   0x9E,
   0x8E,
   0xA7,
   0xD3,
   0xF1,
   0x68,
   0xB7,
   0x3C,
   0x1E,
   0x8F,
   0xA7,
   0xE3,
   0xF1,
   0x18,
   0xBB,
   0x3C,
   0x1F,
   0x8F,
   0xC7,
   0xE3,
   0xF1,
   0xD4,
   0xBE,
   0x3C,
   0x1F,
   0xCF,
   0xC7,
   0xF3,
   0xF1,
   0x98,
   0xC2,
   0x3E,
   0x9E,
   0xCF,
   0xE7,
   0xE3,
   0xF9,
   0x68,
   0xC6,
   0x3E,
   0x1F,
   0xD0,
   0xE7,
   0xF3,
   0xF9,
   0x40,
   0xCA,
   0x3E,
   0xA0,
   0x0F,
   0xE8,
   0x03,
   0xFA,
   0x24,
   0xCE,
   0x40,
   0x20,
   0xD0,
   0x07,
   0x04,
   0xFA,
   0x14,
   0xD2,
   0x40,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x0D,
   0xD6,
   0x40,
   0x21,
   0x50,
   0x08,
   0x04,
   0x02,
   0x11,
   0xDA,
   0x42,
   0xA1,
   0x10,
   0x28,
   0x14,
   0x02,
   0x1D,
   0xDE,
   0x42,
   0xA1,
   0x50,
   0x28,
   0x14,
   0x0A,
   0x35,
   0xE2,
   0x44,
   0xA1,
   0x90,
   0x28,
   0x14,
   0x12,
   0x55,
   0xE6,
   0x44,
   0x21,
   0x91,
   0x28,
   0x24,
   0x12,
   0x81,
   0xEA,
   0x44,
   0x22,
   0x91,
   0x48,
   0x24,
   0x12,
   0xB9,
   0xEE,
   0x44,
   0x23,
   0xD1,
   0x48,
   0x24,
   0x12,
   0xFD,
   0xF2,
   0x44,
   0xA3,
   0xD1,
   0x48,
   0x34,
   0x12,
   0x49,
   0xF7,
   0x46,
   0xA3,
   0xD1,
   0x68,
   0x34,
   0x1A,
   0x9D,
   0xFB,

};
#else
WORD const PreLUT_2_2[512]=
{
   0, 0, 0, 0, 0, 0, 64, 0, 4, 2048,
   0, 32768, 16, 16, 64, 256, 32, 16, 64, 32770,
   52, 16, 8256, 32770, 76, 2064, 8256, 33026, 108, 2064,
   8320, 33026, 144, 4112, 8320, 33028, 188, 4112, 16449, 260,
   240, 2080, 16449, 516, 296, 4112, 16513, 516, 356, 4128,
   24705, 516, 428, 4128, 16577, 772, 504, 4144, 16577, 772,
   584, 6192, 16577, 33542, 676, 4144, 24769, 33544, 772, 6192,
   24770, 774, 872, 8240, 32962, 776, 984, 8240, 33025, 33800,
   1104, 6208, 33026, 1032, 1228, 8256, 33026, 1034, 1360, 8272,
   33026, 33800, 1500, 8272, 41218, 33802, 1648, 8272, 41282, 34058,
   1800, 10320, 41346, 34058, 1964, 10336, 41282, 34314, 2136, 10336,
   41346, 34314, 2312, 12384, 41347, 1548, 2500, 10336, 49603, 1548,
   2692, 12384, 57731, 1804, 2892, 14432, 57731, 34318, 3104, 12400,
   57795, 1806, 3320, 14448, 57795, 34574, 3544, 16496, 57796, 1806,
   3780, 14464, 57859, 34832, 4020, 16512, 57860, 2064, 4272, 16513,
   516, 2064, 4528, 16529, 516, 34832, 4796, 16529, 580, 34834,
   5072, 16529, 8772, 34834, 5352, 18577, 8836, 35090, 5644, 18593,
   8773, 2324, 5944, 20625, 17028, 35348, 6252, 20641, 17029, 2580,
   6572, 20641, 17029, 2582, 6896, 20657, 17029, 35350, 7232, 20657,
   17093, 35604, 7572, 22705, 25285, 35606, 7924, 22705, 33477, 35608,
   8284, 24753, 25350, 2840, 8652, 24769, 33478, 3096, 9032, 24769,
   33542, 3096, 9416, 26817, 33606, 3098, 9812, 26817, 41798, 3354,
   10216, 26833, 41798, 36122, 10632, 26833, 41798, 36378, 11052, 28881,
   41862, 36378, 11484, 28881, 50055, 3356, 11924, 28897, 50055, 3612,
   12372, 30945, 50055, 36382, 12832, 28913, 58247, 36382, 13300, 30945,
   58311, 36638, 13776, 30961, 58312, 3870, 14260, 33010, 967, 36896,
   14756, 33010, 1032, 3872, 15260, 33026, 1032, 4128, 15772, 35074,
   1096, 4130, 16296, 35074, 9224, 37152, 16828, 35090, 9288, 4386,
   17368, 37138, 9288, 37156, 17920, 35106, 9352, 37412, 18480, 37138,
   17545, 4644, 19048, 37154, 17609, 4644, 19628, 37170, 17545, 37414,
   20216, 39202, 25801, 4902, 20816, 39202, 25801, 37670, 21424, 39218,
   25802, 4902, 22040, 39234, 25865, 37928, 22664, 41282, 34058, 4904,
   23300, 41298, 34058, 5162, 23948, 41298, 34058, 37930, 24604, 41298,
   42250, 38186, 25268, 43346, 42314, 38186, 25944, 43346, 42378, 38442,
   26628, 43362, 42379, 5674, 27320, 45410, 50571, 5676, 28024, 45410,
   58763, 5932, 28740, 45410, 58827, 5934, 29460, 47474, 58827, 38702,
   30196, 47474, 58827, 38958, 30936, 49523, 1484, 5936, 31692, 47491,
   1548, 5936, 32452, 49539, 9740, 6192, 33228, 49539, 9740, 38962,
   34008, 51587, 9804, 39216, 34800, 51603, 9804, 39474, 35604, 51619,
   9805, 6452, 36416, 53651, 18060, 39476, 37240, 53667, 18061, 6708,
   38072, 53667, 26253, 6964, 38916, 53683, 18125, 6966, 39768, 55715,
   26317, 39734, 40628, 57779, 26318, 6966, 41504, 55747, 26381, 39992,
   42384, 57795, 34574, 7224, 43280, 57795, 34574, 39992, 44184, 57795,
   42766, 40248, 45096, 59843, 42830, 40250, 46020, 59859, 42831, 7482,
   46952, 61907, 51023, 7484, 47896, 61923, 51023, 7740, 48852, 61923,
   51087, 7996, 49816, 63971, 51151, 7996, 50792, 63971, 59343, 40764,
   51776, 63987, 59407, 40766, 52773, 499, 59407, 41022, 53780, 64004,
   2063, 41024, 54797, 516, 2064, 8256, 55825, 516, 10256, 8512,
   56861, 2564, 10320, 8514, 57909, 2580, 10320, 41282, 58965, 4628,
   10384, 41538, 60037, 2596, 10385, 8770, 61113, 4644, 18577, 8772,
   62205, 4644, 26769, 9028, 63305, 4660, 26769, 41796, 64413, 6708,
   26833, 41798
}; //Size = 512, number of gamma entries = 1024
#endif

DWORD const LUT_Sim[]=
{
   0X1C3870E1,
   0XFFFF870E,
   0X1C3870E1,
   0XFDFF870E,
   0X1C3870E1,
   0XFBFF870E,
   0X1C3870E1,
   0XF9FF870E,
   0X1C3870E1,
   0XF7FF870E,
   0X1C3870E1,
   0XF5FF870E,
   0X1C3870E1,
   0XF3FF870E,
   0X1C3870E1,
   0XF1FF870E,
   0X1C3870E1,
   0XEFFF870E,
   0X1C3870E1,
   0XEDFF870E,
   0X1C3870E1,
   0XEBFF870E,
   0X1C3870E1,
   0XE9FF870E,
   0X1C3870E1,
   0XE7FF870E,
   0X1C3870E1,
   0XE5FF870E,
   0X1C3870E1,
   0XE3FF870E,
   0X1C3870E1,
   0XE1FF870E,
   0X1C3870E1,
   0XDFFF870E,
   0X1C3870E1,
   0XDDFF870E,
   0X1C3870E1,
   0XDBFF870E,
   0X1C3870E1,
   0XD9FF870E,
   0X1C3870E1,
   0XD7FF870E,
   0X1C3870E1,
   0XD5FF870E,
   0X1C3870E1,
   0XD3FF870E,
   0X1C3870E1,
   0XD1FF870E,
   0X1C3870E1,
   0XCFFF870E,
   0X1C3870E1,
   0XCDFF870E,
   0X1C3870E1,
   0XCBFF870E,
   0X1C3870E1,
   0XC9FF870E,
   0X1C3870E1,
   0XC7FF870E,
   0X1C3870E1,
   0XC5FF870E,
   0X1C3870E1,
   0XC3FF870E,
   0X1C3870E1,
   0XC1FF870E,
   0X1C3870E1,
   0XBFFF870E,
   0X1C3870E1,
   0XBDFF870E,
   0X1C3870E1,
   0XBBFF870E,
   0X1C3870E1,
   0XB9FF870E,
   0X1C3870E1,
   0XB7FF870E,
   0X1C3870E1,
   0XB5FF870E,
   0X1C3870E1,
   0XB3FF870E,
   0X1C3870E1,
   0XB1FF870E,
   0X1C3870E1,
   0XAFFF870E,
   0X1C3870E1,
   0XADFF870E,
   0X1C3870E1,
   0XABFF870E,
   0X1C3870E1,
   0XA9FF870E,
   0X1C3870E1,
   0XA7FF870E,
   0X1C3870E1,
   0XA5FF870E,
   0X1C3870E1,
   0XA3FF870E,
   0X1C3870E1,
   0XA1FF870E,
   0X1C3870E1,
   0X9FFF870E,
   0X1C3870E1,
   0X9DFF870E,
   0X1C3870E1,
   0X9BFF870E,
   0X1C3870E1,
   0X99FF870E,
   0X1C3870E1,
   0X97FF870E,
   0X1C3870E1,
   0X95FF870E,
   0X1C3870E1,
   0X93FF870E,
   0X1C3870E1,
   0X91FF870E,
   0X1C3870E1,
   0X8FFF870E,
   0X1C3870E1,
   0X8DFF870E,
   0X1C3870E1,
   0X8BFF870E,
   0X1C3870E1,
   0X89FF870E,
   0X1C3870E1,
   0X87FF870E,
   0X1C3870E1,
   0X85FF870E,
   0X1C3870E1,
   0X83FF870E,
   0X1C3870E1,
   0X81FF870E,
   0X1C3870E1,
   0X7FFF870E,
   0X1C3870E1,
   0X7DFF870E,
   0X1C3870E1,
   0X7BFF870E,
   0X1C3870E1,
   0X79FF870E,
   0X1C3870E1,
   0X77FF870E,
   0X1C3870E1,
   0X75FF870E,
   0X1C3870E1,
   0X73FF870E,
   0X1C3870E1,
   0X71FF870E,
   0X1C3870E1,
   0X6FFF870E,
   0X1C3870E1,
   0X6DFF870E,
   0X1C3870E1,
   0X6BFF870E,
   0X1C3870E1,
   0X69FF870E,
   0X1C3870E1,
   0X67FF870E,
   0X1C3870E1,
   0X65FF870E,
   0X1C3870E1,
   0X63FF870E,
   0X1C3870E1,
   0X61FF870E,
   0X1C3870E1,
   0X5FFF870E,
   0X1C3870E1,
   0X5DFF870E,
   0X1C3870E1,
   0X5BFF870E,
   0X1C3870E1,
   0X59FF870E,
   0X1C3870E1,
   0X57FF870E,
   0X1C3870E1,
   0X55FF870E,
   0X1C3870E1,
   0X53FF870E,
   0X1C3870E1,
   0X51FF870E,
   0X1C3870E1,
   0X4FFF870E,
   0X1C3870E1,
   0X4DFF870E,
   0X1C3870E1,
   0X4BFF870E,
   0X1C3870E1,
   0X49FF870E,
   0X1C3870E1,
   0X47FF870E,
   0X1C3870E1,
   0X45FF870E,
   0X1C3870E1,
   0X43FF870E,
   0X1C3870E1,
   0X41FF870E,
   0X1C3870E1,
   0X3FFF870E,
   0X1C3870E1,
   0X3DFF870E,
   0X1C3870E1,
   0X3BFF870E,
   0X1C3870E1,
   0X39FF870E,
   0X1C3870E1,
   0X37FF870E,
   0X1C3870E1,
   0X35FF870E,
   0X1C3870E1,
   0X33FF870E,
   0X1C3870E1,
   0X31FF870E,
   0X1C3870E1,
   0X2FFF870E,
   0X1C3870E1,
   0X2DFF870E,
   0X1C3870E1,
   0X2BFF870E,
   0X1C3870E1,
   0X29FF870E,
   0X1C3870E1,
   0X27FF870E,
   0X1C3870E1,
   0X25FF870E,
   0X1C3870E1,
   0X23FF870E,
   0X1C3870E1,
   0X21FF870E,
   0X1C3870E1,
   0X1FFF870E,
   0X1C3870E1,
   0X1DFF870E,
   0X1C3870E1,
   0X1BFF870E,
   0X1C3870E1,
   0X19FF870E,
   0X1C3870E1,
   0X17FF870E,
   0X1C3870E1,
   0X15FF870E,
   0X1C3870E1,
   0X13FF870E,
   0X1C3870E1,
   0X11FF870E,
   0X1C3870E1,
   0X0FFF870E,
   0X1C3870E1,
   0X0DFF870E,
   0X1C3870E1,
   0X0BFF870E,
   0X1C3870E1,
   0X09FF870E,
   0X1C3870E1,
   0X07FF870E,
   0X1C3870E1,
   0X05FF870E,
   0X1C3870E1,
   0X03FF870E,
   0X1C3870E1,
   0X01FF870E,

};

BYTE const LUT_Linear[]=
#if 1
{
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x08,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x10,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x18,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x20,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x28,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x30,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x38,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x40,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x48,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x50,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x58,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x60,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x68,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x70,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x78,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x88,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x90,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x98,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF0,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF8,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x08,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x10,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x18,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x20,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x28,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x30,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x38,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x40,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x48,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x50,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x58,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x60,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x68,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x70,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x78,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x88,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x90,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x98,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF0,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF8,
   0x01,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x08,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x10,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x18,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x20,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x28,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x30,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x38,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x40,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x48,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x50,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x58,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x60,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x68,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x70,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x78,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x88,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x90,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x98,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF0,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF8,
   0x02,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x08,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x10,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x18,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x20,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x28,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x30,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x38,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x40,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x48,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x50,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x58,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x60,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x68,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x70,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x78,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x80,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x88,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x90,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x98,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xA8,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xB8,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xC8,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xD8,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xE8,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF0,
   0x03,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0xF8,
   0x03,

};
#else
{
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x00,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x02,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x04,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x06,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x08,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x0E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x10,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x12,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x14,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x16,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x18,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x1E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x20,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x22,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x24,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x26,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x28,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x2E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x30,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x32,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x34,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x36,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x38,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x3E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x40,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x42,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x44,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x46,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x48,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x4E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x50,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x52,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x54,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x56,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x58,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x5E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x60,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x62,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x64,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x66,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x68,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x6E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x70,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x72,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x74,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x76,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x78,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x7E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x80,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x82,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x84,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x86,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x88,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x8E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x90,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x92,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x94,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x96,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x98,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9A,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9C,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0x9E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xA8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xAE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xB8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xBE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xC8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xCE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xD8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xDE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xE8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xEE,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF0,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF2,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF4,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF6,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xF8,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFA,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFC,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x00,
   0xFE,

};
#endif

#if 1
WORD const PostLUT_1over2_2_Tool[]=
{
   65534, 65535, 65535, 3, 52628, 5416, 7659, 7223, 48244, 12254,
   11320, 9898, 12898, 44314, 50038, 11897, 11606, 52118, 33525, 13561,
   10318, 10836, 21157, 15009, 42056, 43346, 14948, 16305, 8772, 26769,
   6708, 17489, 41022, 2127, 2564, 18585, 7738, 51087, 63987, 19604,
   7480, 34638, 59859, 20568, 39732, 34509, 57779, 21476, 39476, 18060,
   53683, 22344, 39216, 9804, 51603, 23172, 5936, 1548, 51587, 23964,
   38702, 58827, 49522, 24728, 5676, 58763, 47458, 25464, 5418, 42379,
   45410, 26176, 37930, 42314, 43346, 26868, 37928, 34058, 41298, 27536,
   37928, 34057, 41282, 28184, 37670, 25865, 41266, 28816, 4902, 25801,
   39218, 29432, 4900, 25737, 39202, 30032, 4642, 17545, 37154, 30620,
   37410, 9352, 37154, 31192, 37154, 9352, 35090, 31756, 4386, 9288,
   35090, 32304, 4384, 1096, 33042, 32844, 4128, 1096, 33026, 33372,
   4128, 1032, 33026, 33888, 3872, 58376, 33025, 34396, 36894, 967,
   33010, 34896, 36638, 58311, 30977, 35388, 36382, 58311, 30961, 35872,
   3870, 58311, 30945, 36348, 3868, 58247, 30945, 36816, 3612, 50119,
   30945, 37276, 3612, 50055, 28897, 37732, 36380, 50054, 28897, 38180,
   3610, 49991, 26849, 38624, 36124, 41862, 26849, 39060, 3354, 41799,
   28881, 39488, 36122, 41798, 28881, 39912, 36122, 41798, 26833, 40332,
   36120, 41798, 26817, 40748, 3354, 41798, 26817, 41156, 35866, 41734,
   26817, 41560, 3096, 33606, 24785, 41960, 3096, 41734, 24769, 42356,
   3096, 33542, 26817, 42744, 3096, 33542, 24769, 43132, 3096, 33542,
   24753, 43516, 3094, 33478, 24769, 43892, 3094, 33478, 24753, 44268,
   35862, 25349, 22721, 44640, 35862, 33477, 24753, 45004, 2838, 25286,
   24753, 45368, 35606, 25285, 24753, 45728, 35606, 25285, 22705, 46088,
   35606, 25285, 22705, 46440, 35604, 25285, 22705, 46788, 35606, 25221,
   22705, 47136, 35350, 17093, 22705, 47480, 2838, 17093, 20657, 47824,
   35348, 25221, 22689, 48160, 2582, 17093, 20657, 48496, 35348, 17029,
   20657, 48828, 2580, 17093, 20641, 49160, 2580, 17029, 22689, 49484,
   2580, 17029, 20641, 49812, 2580, 17029, 20641, 50132, 2578, 17029,
   20641, 50452, 2324, 17029, 20641, 50768, 2580, 8837, 20641, 51084,
   2578, 8837, 20641, 51396, 2578, 16965, 20625, 51708, 2324, 16965,
   18593, 52016, 2324, 16965, 20625, 52320, 2322, 16965, 20625, 52624,
   2322, 8773, 18593, 52928, 35346, 16964, 18577, 53228, 35346, 8772,
   18593, 53524, 35090, 8772, 18593, 53820, 35090, 8772, 18577, 54116,
   35090, 8772, 18577, 54408, 35090, 8772, 18577, 54696, 35090, 8772,
   18577, 54984, 35090, 8772, 18561, 55272, 35090, 580, 18577, 55556,
   34834, 8772, 16529, 55840, 34834, 8772, 18561, 56120, 35090, 8708,
   16529, 56400, 2322, 8772, 18561, 56676, 2320, 8772, 18561, 56952,
   34834, 8708, 16529, 57228, 34834, 8708, 18561, 57500, 2320, 580,
   16529, 57772, 2320, 8708, 18561, 58040, 2320, 8708, 16513, 58312,
   2064, 580, 18561, 58576, 2066, 8708, 16513, 58844, 2064, 580,
   16513, 59108, 2066, 516, 18561, 59368, 2320, 516, 16513, 59632,
   2064, 516, 16513, 59892, 2064, 516, 16529, 60148, 2064, 516,
   16513, 60408, 2062, 516, 16513, 60664, 2064, 516, 16513, 60916,
   2064, 57860, 16512, 61172, 2064, 57860, 16512, 61424, 1808, 516,
   14465, 61676, 2062, 57860, 16512, 61924, 1808, 57860, 16512, 62172,
   34832, 515, 16497, 62420, 1808, 57860, 16512, 62664, 1808, 452,
   14465, 62912, 1808, 57860, 14464, 63156, 34830, 515, 16497, 63396,
   34830, 57859, 14464, 63640, 34830, 57859, 14464, 63880, 34576, 57859,
   14464, 64120, 34830, 451, 16497, 64356, 1806, 452, 14449, 64596,
   34830, 451, 14449, 64832, 34576, 451, 14449, 65068, 1806, 57796,
   14464, 65300
}; //Size = 512, number of gamma entries = 1024


BYTE const PostLUT_1over2_2[1024]=
{
   0xE6,
   0xFE,
   0xFF,
   0xFF,
   0xFF,
   0xFF,
   0x03,
   0x00,
   0x94,
   0xCD,
   0x28,
   0x15,
   0xEB,
   0x1D,
   0x37,
   0x1C,
   0x74,
   0xBC,
   0xDE,
   0x2F,
   0x38,
   0x2C,
   0xAA,
   0x26,
   0x62,
   0x32,
   0x1A,
   0xAD,
   0x76,
   0xC3,
   0x79,
   0x2E,
   0x58,
   0xAC,
   0x56,
   0xCB,
   0xF5,
   0x82,
   0xF9,
   0x34,
   0x4E,
   0x28,
   0x54,
   0x2A,
   0xA5,
   0x52,
   0xA1,
   0x3A,
   0x48,
   0xA4,
   0x52,
   0xC9,
   0x54,
   0x3A,
   0xB1,
   0x3F,
   0x44,
   0x22,
   0x91,
   0x68,
   0x34,
   0x1A,
   0x51,
   0x44,
   0x3E,
   0x20,
   0x10,
   0x08,
   0x04,
   0x0A,
   0x99,
   0x48,
   0x3A,
   0x1E,
   0x8F,
   0xC7,
   0xF3,
   0xF9,
   0x94,
   0x4C,
   0x38,
   0x1C,
   0x4E,
   0x87,
   0xD3,
   0xE9,
   0x58,
   0x50,
   0x34,
   0x9B,
   0xCD,
   0x86,
   0xB3,
   0xE1,
   0xE4,
   0x53,
   0x34,
   0x9A,
   0x8C,
   0x46,
   0xB3,
   0xD1,
   0x48,
   0x57,
   0x30,
   0x99,
   0x4C,
   0x26,
   0x93,
   0xC9,
   0x84,
   0x5A,
   0x30,
   0x17,
   0x0C,
   0x06,
   0x83,
   0xC9,
   0x9C,
   0x5D,
   0x2E,
   0x97,
   0xCB,
   0xE5,
   0x72,
   0xC1,
   0x98,
   0x60,
   0x2C,
   0x16,
   0x8B,
   0xE5,
   0x62,
   0xB9,
   0x78,
   0x63,
   0x2A,
   0x15,
   0x8B,
   0xA5,
   0x62,
   0xB1,
   0x40,
   0x66,
   0x2A,
   0x94,
   0x4A,
   0xA5,
   0x52,
   0xA9,
   0xF4,
   0x68,
   0x28,
   0x94,
   0x0A,
   0x85,
   0x52,
   0xA1,
   0x90,
   0x6B,
   0x28,
   0x94,
   0x09,
   0x85,
   0x42,
   0xA1,
   0x18,
   0x6E,
   0x26,
   0x93,
   0x09,
   0x65,
   0x42,
   0x99,
   0x90,
   0x70,
   0x26,
   0x13,
   0xC9,
   0x64,
   0x32,
   0x99,
   0xF8,
   0x72,
   0x24,
   0x13,
   0x89,
   0x64,
   0x22,
   0x99,
   0x50,
   0x75,
   0x22,
   0x12,
   0x89,
   0x44,
   0x22,
   0x91,
   0x9C,
   0x77,
   0x22,
   0x92,
   0x88,
   0x24,
   0x22,
   0x91,
   0xD8,
   0x79,
   0x22,
   0x91,
   0x88,
   0x24,
   0x12,
   0x89,
   0x0C,
   0x7C,
   0x22,
   0x11,
   0x48,
   0x24,
   0x12,
   0x89,
   0x30,
   0x7E,
   0x20,
   0x11,
   0x48,
   0x04,
   0x12,
   0x81,
   0x4C,
   0x80,
   0x20,
   0x10,
   0x48,
   0x04,
   0x02,
   0x81,
   0x5C,
   0x82,
   0x20,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x60,
   0x84,
   0x20,
   0x0F,
   0x08,
   0xE4,
   0x01,
   0x81,
   0x5C,
   0x86,
   0x1E,
   0x90,
   0xC7,
   0x03,
   0xF2,
   0x80,
   0x50,
   0x88,
   0x1E,
   0x8F,
   0xC7,
   0xE3,
   0x01,
   0x79,
   0x3C,
   0x8A,
   0x1E,
   0x8E,
   0xC7,
   0xE3,
   0xF1,
   0x78,
   0x20,
   0x8C,
   0x1E,
   0x0F,
   0xC7,
   0xE3,
   0xE1,
   0x78,
   0xFC,
   0x8D,
   0x1C,
   0x0F,
   0x87,
   0xE3,
   0xE1,
   0x78,
   0xD0,
   0x8F,
   0x1C,
   0x0E,
   0xC7,
   0xC3,
   0xE1,
   0x70,
   0xA0,
   0x91,
   0x1C,
   0x0E,
   0x87,
   0xC3,
   0xE1,
   0x70,
   0x64,
   0x93,
   0x1C,
   0x8E,
   0x86,
   0xC3,
   0xE1,
   0x70,
   0x24,
   0x95,
   0x1A,
   0x0E,
   0x47,
   0xC3,
   0xE1,
   0x68,
   0xE0,
   0x96,
   0x1C,
   0x8D,
   0x86,
   0xA3,
   0xE1,
   0x68,
   0x94,
   0x98,
   0x1A,
   0x0D,
   0x47,
   0xA3,
   0xD1,
   0x70,
   0x40,
   0x9A,
   0x1A,
   0x8D,
   0x46,
   0xA3,
   0xD1,
   0x70,
   0xE8,
   0x9B,
   0x1A,
   0x8D,
   0x46,
   0xA3,
   0xD1,
   0x68,
   0x8C,
   0x9D,
   0x18,
   0x8D,
   0x46,
   0xA3,
   0xC1,
   0x68,
   0x2C,
   0x9F,
   0x1A,
   0x0D,
   0x46,
   0xA3,
   0xC1,
   0x68,
   0xC4,
   0xA0,
   0x1A,
   0x8C,
   0x06,
   0xA3,
   0xC1,
   0x68,
   0x58,
   0xA2,
   0x1A,
   0x0C,
   0x46,
   0x83,
   0xD1,
   0x60,
   0xE8,
   0xA3,
   0x18,
   0x0C,
   0x06,
   0xA3,
   0xC1,
   0x60,
   0x74,
   0xA5,
   0x18,
   0x0C,
   0x06,
   0x83,
   0xC1,
   0x60,
   0xFC,
   0xA6,
   0x18,
   0x0C,
   0x06,
   0x83,
   0xC1,
   0x60,
   0x7C,
   0xA8,
   0x18,
   0x0C,
   0x06,
   0x83,
   0xB1,
   0x60,
   0xFC,
   0xA9,
   0x16,
   0x0C,
   0xC6,
   0x82,
   0xC1,
   0x60,
   0x74,
   0xAB,
   0x16,
   0x0C,
   0xC6,
   0x82,
   0xB1,
   0x60,
   0xEC,
   0xAC,
   0x16,
   0x8C,
   0x05,
   0x63,
   0xC1,
   0x58,
   0x60,
   0xAE,
   0x16,
   0x8C,
   0xC5,
   0x82,
   0xB1,
   0x60,
   0xCC,
   0xAF,
   0x16,
   0x0B,
   0xC6,
   0x62,
   0xB1,
   0x60,
   0x38,
   0xB1,
   0x16,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0x60,
   0xA0,
   0xB2,
   0x16,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0x58,
   0x08,
   0xB4,
   0x16,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0x58,
   0x68,
   0xB5,
   0x14,
   0x8B,
   0xC5,
   0x62,
   0xB1,
   0x58,
   0xC4,
   0xB6,
   0x16,
   0x8B,
   0x85,
   0x62,
   0xB1,
   0x58,
   0x20,
   0xB8,
   0x16,
   0x8A,
   0xC5,
   0x42,
   0xB1,
   0x58,
   0x78,
   0xB9,
   0x16,
   0x0B,
   0xC5,
   0x42,
   0xB1,
   0x50,
   0xD0,
   0xBA,
   0x16,
   0x8A,
   0x85,
   0x62,
   0xA1,
   0x58,
   0x20,
   0xBC,
   0x16,
   0x0A,
   0xC5,
   0x42,
   0xB1,
   0x50,
   0x70,
   0xBD,
   0x14,
   0x8A,
   0x85,
   0x42,
   0xB1,
   0x50,
   0xBC,
   0xBE,
   0x14,
   0x0A,
   0xC5,
   0x42,
   0xA1,
   0x50,
   0x08,
   0xC0,
   0x16,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x58,
   0x4C,
   0xC1,
   0x14,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x50,
   0x94,
   0xC2,
   0x14,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x50,
   0xD4,
   0xC3,
   0x14,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x50,
   0x14,
   0xC5,
   0x12,
   0x0A,
   0x85,
   0x42,
   0xA1,
   0x50,
   0x50,
   0xC6,
   0x14,
   0x0A,
   0x45,
   0x42,
   0xA1,
   0x50,
   0x8C,
   0xC7,
   0x12,
   0x0A,
   0x45,
   0x42,
   0xA1,
   0x50,
   0xC4,
   0xC8,
   0x12,
   0x8A,
   0x84,
   0x42,
   0x91,
   0x50,
   0xFC,
   0xC9,
   0x14,
   0x09,
   0x45,
   0x42,
   0x91,
   0x50,
   0x30,
   0xCB,
   0x12,
   0x8A,
   0x84,
   0x22,
   0xA1,
   0x50,
   0x60,
   0xCC,
   0x12,
   0x09,
   0x45,
   0x42,
   0x91,
   0x50,
   0x90,
   0xCD,
   0x12,
   0x09,
   0x45,
   0x22,
   0xA1,
   0x48,
   0xC0,
   0xCE,
   0x12,
   0x8A,
   0x44,
   0x42,
   0x91,
   0x48,
   0xEC,
   0xCF,
   0x12,
   0x09,
   0x45,
   0x22,
   0x91,
   0x50,
   0x14,
   0xD1,
   0x12,
   0x89,
   0x44,
   0x22,
   0xA1,
   0x48,
   0x3C,
   0xD2,
   0x12,
   0x89,
   0x44,
   0x22,
   0x91,
   0x48,
   0x64,
   0xD3,
   0x12,
   0x89,
   0x44,
   0x22,
   0x91,
   0x48,
   0x88,
   0xD4,
   0x12,
   0x89,
   0x44,
   0x22,
   0x91,
   0x48,
   0xA8,
   0xD5,
   0x12,
   0x89,
   0x44,
   0x22,
   0x91,
   0x48,
   0xC8,
   0xD6,
   0x12,
   0x89,
   0x44,
   0x02,
   0x91,
   0x48,
   0xE8,
   0xD7,
   0x12,
   0x89,
   0x44,
   0x02,
   0x91,
   0x48,
   0x04,
   0xD9,
   0x12,
   0x88,
   0x44,
   0x22,
   0x91,
   0x40,
   0x20,
   0xDA,
   0x12,
   0x88,
   0x44,
   0x22,
   0x81,
   0x48,
   0x38,
   0xDB,
   0x12,
   0x09,
   0x44,
   0x22,
   0x91,
   0x40,
   0x50,
   0xDC,
   0x12,
   0x09,
   0x44,
   0x02,
   0x91,
   0x48,
   0x64,
   0xDD,
   0x10,
   0x09,
   0x44,
   0x02,
   0x91,
   0x48,
   0x78,
   0xDE,
   0x12,
   0x88,
   0x04,
   0x22,
   0x81,
   0x48,
   0x8C,
   0xDF,
   0x12,
   0x88,
   0x04,
   0x22,
   0x81,
   0x48,
   0x9C,
   0xE0,
   0x10,
   0x09,
   0x44,
   0x02,
   0x81,
   0x48,
   0xAC,
   0xE1,
   0x10,
   0x88,
   0x04,
   0x22,
   0x81,
   0x40,
   0xBC,
   0xE2,
   0x10,
   0x09,
   0x04,
   0x22,
   0x81,
   0x40,
   0xC8,
   0xE3,
   0x12,
   0x08,
   0x44,
   0x02,
   0x81,
   0x48,
   0xD0,
   0xE4,
   0x12,
   0x08,
   0x04,
   0x22,
   0x81,
   0x40,
   0xDC,
   0xE5,
   0x10,
   0x08,
   0x04,
   0x22,
   0x81,
   0x40,
   0xE4,
   0xE6,
   0x10,
   0x09,
   0x04,
   0x02,
   0x81,
   0x40,
   0xEC,
   0xE7,
   0x10,
   0x88,
   0x04,
   0x02,
   0x81,
   0x40,
   0xF0,
   0xE8,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0xF4,
   0xE9,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0xF8,
   0xEA,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0xF8,
   0xEB,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x40,
   0xF8,
   0xEC,
   0x10,
   0x08,
   0x04,
   0x02,
   0x81,
   0x38,
   0xF8,
   0xED,
   0x10,
   0x08,
   0xC4,
   0x01,
   0x81,
   0x40,
   0xF4,
   0xEE,
   0x10,
   0x08,
   0x04,
   0xE2,
   0x80,
   0x40,
   0xF0,
   0xEF,
   0x10,
   0x07,
   0x04,
   0x02,
   0x81,
   0x38,
   0xEC,
   0xF0,
   0x0E,
   0x08,
   0x04,
   0xE2,
   0x80,
   0x40,
   0xE4,
   0xF1,
   0x0E,
   0x08,
   0x04,
   0xE2,
   0x80,
   0x40,
   0xDC,
   0xF2,
   0x10,
   0x07,
   0x04,
   0x02,
   0x71,
   0x40,
   0xD4,
   0xF3,
   0x0E,
   0x08,
   0xC4,
   0x01,
   0x81,
   0x38,
   0xCC,
   0xF4,
   0x0E,
   0x08,
   0xC4,
   0x01,
   0x81,
   0x38,
   0xC0,
   0xF5,
   0x10,
   0x07,
   0xC4,
   0x01,
   0x81,
   0x38,
   0xB4,
   0xF6,
   0x0E,
   0x88,
   0x03,
   0xE2,
   0x80,
   0x40,
   0xA4,
   0xF7,
   0x0E,
   0x88,
   0x03,
   0xE2,
   0x80,
   0x38,
   0x98,
   0xF8,
   0x0E,
   0x88,
   0x03,
   0xE2,
   0x80,
   0x38,
   0x88,
   0xF9,
   0x0E,
   0x88,
   0x03,
   0xE2,
   0x80,
   0x38,
   0x78,
   0xFA,
   0x0E,
   0x07,
   0xC4,
   0x01,
   0x71,
   0x40,
   0x64,
   0xFB,
   0x0E,
   0x07,
   0xC4,
   0xE1,
   0x80,
   0x38,
   0x54,
   0xFC,
   0x0E,
   0x07,
   0xC4,
   0xE1,
   0x80,
   0x38,
   0x40,
   0xFD,
   0x0E,
   0x88,
   0xC3,
   0x01,
   0x71,
   0x38,
   0x2C,
   0xFE,
   0x0E,
   0x07,
   0xC4,
   0xE1,
   0x80,
   0x38,
   0x14,
   0xFF,

};

#else
WORD const PostLUT_1over2_2[512]=
{
   3, 65535, 65535, 65534, 7223, 7659, 5416, 52628, 9898, 11320,
   12254, 48244, 11897, 50038, 44314, 12898, 13561, 33525, 52118, 11606,
   15009, 21157, 10836, 10318, 16305, 14948, 43346, 42056, 17489, 6708,
   26769, 8772, 18585, 2564, 2127, 41022, 19604, 63987, 51087, 7738,
   20568, 59859, 34638, 7480, 21476, 57779, 34509, 39732, 22344, 53683,
   18060, 39476, 23172, 51603, 9804, 39216, 23964, 51587, 1548, 5936,
   24728, 49522, 58827, 38702, 25464, 47458, 58763, 5676, 26176, 45410,
   42379, 5418, 26868, 43346, 42314, 37930, 27536, 41298, 34058, 37928,
   28184, 41282, 34057, 37928, 28816, 41266, 25865, 37670, 29432, 39218,
   25801, 4902, 30032, 39202, 25737, 4900, 30620, 37154, 17545, 4642,
   31192, 37154, 9352, 37410, 31756, 35090, 9352, 37154, 32304, 35090,
   9288, 4386, 32844, 33042, 1096, 4384, 33372, 33026, 1096, 4128,
   33888, 33026, 1032, 4128, 34396, 33025, 58376, 3872, 34896, 33010,
   967, 36894, 35388, 30977, 58311, 36638, 35872, 30961, 58311, 36382,
   36348, 30945, 58311, 3870, 36816, 30945, 58247, 3868, 37276, 30945,
   50119, 3612, 37732, 28897, 50055, 3612, 38180, 28897, 50054, 36380,
   38624, 26849, 49991, 3610, 39060, 26849, 41862, 36124, 39488, 28881,
   41799, 3354, 39912, 28881, 41798, 36122, 40332, 26833, 41798, 36122,
   40748, 26817, 41798, 36120, 41156, 26817, 41798, 3354, 41560, 26817,
   41734, 35866, 41960, 24785, 33606, 3096, 42356, 24769, 41734, 3096,
   42744, 26817, 33542, 3096, 43132, 24769, 33542, 3096, 43516, 24753,
   33542, 3096, 43892, 24769, 33478, 3094, 44268, 24753, 33478, 3094,
   44640, 22721, 25349, 35862, 45004, 24753, 33477, 35862, 45368, 24753,
   25286, 2838, 45728, 24753, 25285, 35606, 46088, 22705, 25285, 35606,
   46440, 22705, 25285, 35606, 46788, 22705, 25285, 35604, 47136, 22705,
   25221, 35606, 47480, 22705, 17093, 35350, 47824, 20657, 17093, 2838,
   48160, 22689, 25221, 35348, 48496, 20657, 17093, 2582, 48828, 20657,
   17029, 35348, 49160, 20641, 17093, 2580, 49484, 22689, 17029, 2580,
   49812, 20641, 17029, 2580, 50132, 20641, 17029, 2580, 50452, 20641,
   17029, 2578, 50768, 20641, 17029, 2324, 51084, 20641, 8837, 2580,
   51396, 20641, 8837, 2578, 51708, 20625, 16965, 2578, 52016, 18593,
   16965, 2324, 52320, 20625, 16965, 2324, 52624, 20625, 16965, 2322,
   52928, 18593, 8773, 2322, 53228, 18577, 16964, 35346, 53524, 18593,
   8772, 35346, 53820, 18593, 8772, 35090, 54116, 18577, 8772, 35090,
   54408, 18577, 8772, 35090, 54696, 18577, 8772, 35090, 54984, 18577,
   8772, 35090, 55272, 18561, 8772, 35090, 55556, 18577, 580, 35090,
   55840, 16529, 8772, 34834, 56120, 18561, 8772, 34834, 56400, 16529,
   8708, 35088, 56676, 18561, 8772, 2322, 56952, 18561, 8772, 2320,
   57228, 16529, 8708, 34834, 57500, 18561, 8708, 34834, 57772, 16529,
   580, 2320, 58040, 18561, 8708, 2320, 58312, 16513, 8708, 2320,
   58576, 18561, 580, 2064, 58844, 16513, 8708, 2066, 59108, 16513,
   580, 2064, 59368, 18561, 516, 2066, 59632, 16513, 516, 2320,
   59892, 16513, 516, 2064, 60148, 16529, 516, 2064, 60408, 16513,
   516, 2064, 60664, 16513, 516, 2062, 60916, 16513, 516, 2064,
   61172, 16512, 57860, 2064, 61424, 16512, 57860, 2064, 61676, 14465,
   516, 1808, 61924, 16512, 57860, 2062, 62172, 16512, 57860, 1808,
   62420, 16497, 515, 34832, 62664, 16512, 57860, 1808, 62912, 14465,
   452, 1808, 63156, 14464, 57860, 1808, 63396, 16497, 515, 34830,
   63640, 14464, 57859, 34830, 63880, 14464, 57859, 34830, 64120, 14464,
   57859, 34576, 64356, 16497, 451, 34830, 64596, 14449, 452, 1806,
   64832, 14449, 451, 34830, 65068, 14449, 451, 34576, 65300, 14464,
   57796, 1806
}; //Size = 512, number of gamma entries = 1024
#endif

WORD const SteepLUT_2[]=
{
   0  ,
   2  ,
   4  ,
   6  ,
   8  ,
   10 ,
   12 ,
   14 ,
   16 ,
   18 ,
   20 ,
   22 ,
   24 ,
   26 ,
   28 ,
   30 ,
   32 ,
   34 ,
   36 ,
   38 ,
   40 ,
   42 ,
   44 ,
   46 ,
   48 ,
   50 ,
   52 ,
   54 ,
   56 ,
   58 ,
   60 ,
   62 ,
   64 ,
   66 ,
   68 ,
   70 ,
   72 ,
   74 ,
   76 ,
   78 ,
   80 ,
   82 ,
   84 ,
   86 ,
   88 ,
   90 ,
   92 ,
   94 ,
   96 ,
   98 ,
   100,
   102,
   104,
   106,
   108,
   110,
   112,
   114,
   116,
   118,
   120,
   122,
   124,
   126,
   128,
   130,
   132,
   134,
   136,
   138,
   140,
   142,
   144,
   146,
   148,
   150,
   152,
   154,
   156,
   158,
   160,
   162,
   164,
   166,
   168,
   170,
   172,
   174,
   176,
   178,
   180,
   182,
   184,
   186,
   188,
   190,
   192,
   194,
   196,
   198,
   200,
   202,
   204,
   206,
   208,
   210,
   212,
   214,
   216,
   218,
   220,
   222,
   224,
   226,
   228,
   230,
   232,
   234,
   236,
   238,
   240,
   242,
   244,
   246,
   248,
   250,
   252,
   254,
   256,

};

WORD const SteepLUT_Linear[]=
{
   0  ,
   1  ,
   2  ,
   3  ,
   4  ,
   5  ,
   6  ,
   7  ,
   8  ,
   9  ,
   10 ,
   11 ,
   12 ,
   13 ,
   14 ,
   15 ,
   16 ,
   17 ,
   18 ,
   19 ,
   20 ,
   21 ,
   22 ,
   23 ,
   24 ,
   25 ,
   26 ,
   27 ,
   28 ,
   29 ,
   30 ,
   31 ,
   32 ,
   33 ,
   34 ,
   35 ,
   36 ,
   37 ,
   38 ,
   39 ,
   40 ,
   41 ,
   42 ,
   43 ,
   44 ,
   45 ,
   46 ,
   47 ,
   48 ,
   49 ,
   50 ,
   51 ,
   52 ,
   53 ,
   54 ,
   55 ,
   56 ,
   57 ,
   58 ,
   59 ,
   60 ,
   61 ,
   62 ,
   63 ,
   64 ,
   65 ,
   66 ,
   67 ,
   68 ,
   69 ,
   70 ,
   71 ,
   72 ,
   73 ,
   74 ,
   75 ,
   76 ,
   77 ,
   78 ,
   79 ,
   80 ,
   81 ,
   82 ,
   83 ,
   84 ,
   85 ,
   86 ,
   87 ,
   88 ,
   89 ,
   90 ,
   91 ,
   92 ,
   93 ,
   94 ,
   95 ,
   96 ,
   97 ,
   98 ,
   99 ,
   100,
   101,
   102,
   103,
   104,
   105,
   106,
   107,
   108,
   109,
   110,
   111,
   112,
   113,
   114,
   115,
   116,
   117,
   118,
   119,
   120,
   121,
   122,
   123,
   124,
   125,
   126,
   127,
   128,
};

WORD const SteepLUT_1over2_2[]=
#if 1
{
   0  ,
   68 ,
   93 ,
   112,
   128,
   141,
   153,
   165,
   175,
   185,
   194,
   202,
   210,
   218,
   226,
   233,
   240,
   247,
   253,
   259,
   266,
   271,
   277,
   283,
   289,
   294,
   299,
   304,
   309,
   314,
   319,
   324,
   329,
   334,
   338,
   343,
   347,
   351,
   356,
   360,
   364,
   368,
   372,
   376,
   380,
   384,
   388,
   392,
   396,
   399,
   403,
   407,
   410,
   414,
   417,
   421,
   424,
   428,
   431,
   434,
   438,
   441,
   444,
   448,
   451,
   454,
   457,
   460,
   463,
   467,
   470,
   473,
   476,
   479,
   482,
   485,
   488,
   490,
   493,
   496,
   499,
   502,
   505,
   507,
   510,
   513,
   516,
   518,
   521,
   524,
   527,
   529,
   532,
   534,
   537,
   540,
   542,
   545,
   547,
   550,
   552,
   555,
   557,
   560,
   562,
   565,
   567,
   570,
   572,
   574,
   577,
   579,
   582,
   584,
   586,
   589,
   591,
   593,
   596,
   598,
   600,
   602,
   605,
   607,
   609,
   611,
   614,
   616,

};
#else
{
   0   ,
   175 ,
   240 ,
   289 ,
   329 ,
   364 ,
   396 ,
   424 ,
   451 ,
   476 ,
   499 ,
   521 ,
   542 ,
   562 ,
   582 ,
   600 ,
   618 ,
   635 ,
   652 ,
   668 ,
   684 ,
   699 ,
   714 ,
   729 ,
   743 ,
   757 ,
   771 ,
   784 ,
   797 ,
   810 ,
   823 ,
   835 ,
   847 ,
   859 ,
   871 ,
   882 ,
   894 ,
   905 ,
   916 ,
   927 ,
   938 ,
   948 ,
   959 ,
   969 ,
   979 ,
   989 ,
   999 ,
   1009,
   1019,
   1028,
   1038,
   1047,
   1056,
   1066,
   1075,
   1084,
   1093,
   1101,
   1110,
   1119,
   1127,
   1136,
   1144,
   1153,
   1161,
   1169,
   1177,
   1185,
   1193,
   1201,
   1209,
   1217,
   1225,
   1233,
   1240,
   1248,
   1255,
   1263,
   1270,
   1278,
   1285,
   1292,
   1300,
   1307,
   1314,
   1321,
   1328,
   1335,
   1342,
   1349,
   1356,
   1363,
   1369,
   1376,
   1383,
   1389,
   1396,
   1403,
   1409,
   1416,
   1422,
   1429,
   1435,
   1442,
   1448,
   1454,
   1460,
   1467,
   1473,
   1479,
   1485,
   1491,
   1497,
   1504,
   1510,
   1516,
   1522,
   1528,
   1533,
   1539,
   1545,
   1551,
   1557,
   1563,
   1568,
   1574,
   1580,
   1586,



}; //Size = 128, number of gamma entries = 128

//#else
{
   0, 10, 21, 32, 43, 54, 65, 76, 87, 98,
   109, 120, 131, 142, 153, 164, 175, 179, 183, 187,
   191, 195, 199, 203, 207, 211, 216, 220, 224, 228,
   232, 236, 240, 243, 246, 249, 252, 255, 258, 261,
   264, 267, 270, 273, 276, 279, 282, 285, 289, 291,
   294, 296, 299, 301, 304, 306, 309, 311, 314, 316,
   319, 321, 324, 326, 329, 331, 333, 336, 338, 340,
   342, 344, 346, 349, 351, 353, 355, 357, 360, 362,
   364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
   384, 386, 388, 390, 392, 394, 396, 397, 399, 401,
   403, 405, 406, 408, 410, 412, 414, 415, 417, 419,
   421, 423, 424, 426, 428, 429, 431, 433, 434, 436,
   438, 439, 441, 443, 444, 446, 448, 449
}; //Size = 128, number of gamma entries = 128

{
   0  ,
   50 ,
   68 ,
   82 ,
   93 ,
   103,
   112,
   120,
   128,
   135,
   142,
   148,
   154,
   160,
   165,
   170,
   175,
   180,
   185,
   190,
   194,
   198,
   203,
   207,
   211,
   215,
   219,
   223,
   226,
   230,
   233,
   237,
   240,
   244,
   247,
   250,
   254,
   257,
   260,
   263,
   266,
   269,
   272,
   275,
   278,
   281,
   283,
   286,
   289,
   292,
   294,
   297,
   300,
   302,
   305,
   307,
   310,
   312,
   315,
   317,
   320,
   322,
   325,
   327,
   329,
   332,
   334,
   336,
   339,
   341,
   343,
   345,
   348,
   350,
   352,
   354,
   356,
   358,
   360,
   362,
   365,
   367,
   369,
   371,
   373,
   375,
   377,
   379,
   381,
   383,
   385,
   387,
   388,
   390,
   392,
   394,
   396,
   398,
   400,
   402,
   403,
   405,
   407,
   409,
   411,
   413,
   414,
   416,
   418,
   420,
   421,
   423,
   425,
   427,
   428,
   430,
   432,
   433,
   435,
   437,
   438,
   440,
   442,
   443,
   445,
   447,
   448,
   450,
   451,
};

//#else
{
   0  ,
   99 ,
   136,
   164,
   187,
   207,
   225,
   241,
   256,
   270,
   283,
   296,
   308,
   319,
   330,
   341,
   351,
   361,
   370,
   379,
   388,
   397,
   405,
   414,
   422,
   430,
   437,
   445,
   452,
   460,
   467,
   474,
   481,
   488,
   494,
   501,
   507,
   514,
   520,
   526,
   532,
   538,
   544,
   550,
   556,
   561,
   567,
   573,
   578,
   583,
   589,
   594,
   599,
   605,
   610,
   615,
   620,
   625,
   630,
   635,
   640,
   645,
   649,
   654,
   659,
   663,
   668,
   673,
   677,
   682,
   686,
   691,
   695,
   699,
   704,
   708,
   712,
   717,
   721,
   725,
   729,
   733,
   737,
   741,
   745,
   749,
   753,
   757,
   761,
   765,
   769,
   773,
   777,
   781,
   785,
   788,
   792,
   796,
   800,
   803,
   807,
   811,
   814,
   818,
   821,
   825,
   829,
   832,
   836,
   839,
   843,
   846,
   850,
   853,
   856,
   860,
   863,
   867,
   870,
   873,
   877,
   880,
   883,
   887,
   890,
   893,
   896,
   900,
   903,
};
//#else
{
   0   ,
   199 ,
   273 ,
   328 ,
   374 ,
   414 ,
   449 ,
   482 ,
   512 ,
   540 ,
   567 ,
   592 ,
   616 ,
   638 ,
   660 ,
   681 ,
   702 ,
   721 ,
   740 ,
   759 ,
   777 ,
   794 ,
   811 ,
   827 ,
   844 ,
   859 ,
   875 ,
   890 ,
   905 ,
   919 ,
   934 ,
   948 ,
   961 ,
   975 ,
   988 ,
   1001,
   1014,
   1027,
   1040,
   1052,
   1064,
   1076,
   1088,
   1100,
   1111,
   1123,
   1134,
   1145,
   1156,
   1167,
   1178,
   1188,
   1199,
   1209,
   1220,
   1230,
   1240,
   1250,
   1260,
   1270,
   1279,
   1289,
   1299,
   1308,
   1318,
   1327,
   1336,
   1345,
   1354,
   1363,
   1372,
   1381,
   1390,
   1399,
   1407,
   1416,
   1425,
   1433,
   1442,
   1450,
   1458,
   1466,
   1475,
   1483,
   1491,
   1499,
   1507,
   1515,
   1523,
   1531,
   1538,
   1546,
   1554,
   1561,
   1569,
   1577,
   1584,
   1592,
   1599,
   1607,
   1614,
   1621,
   1628,
   1636,
   1643,
   1650,
   1657,
   1664,
   1671,
   1678,
   1685,
   1692,
   1699,
   1706,
   1713,
   1720,
   1726,
   1733,
   1740,
   1747,
   1753,
   1760,
   1767,
   1773,
   1780,
   1786,
   1793,
   1799,
   1805,
};
//#else

#endif
#pragma warn +sig

#endif // #if 0

#if (FEATURE_OVERDRIVE == ENABLE)

#if (DEFAULT_PANEL == LG_WQHD_LM270WQ1)
extern WORD const OD_LUT1_LM270WQ1_6MS[];
extern WORD const OD_LUT2_LM270WQ1_6MS[];
extern WORD const OD_LUT1_LM270WQ1_5MS[];
extern WORD const OD_LUT1_LM270WQ1_6MS_V2[];
#else
extern WORD const OD_LUT1[];
extern WORD const OD_LUT2[];
#endif

WORD ROM * ROM PanelOverDrvLutDefault[] = 
{
   #if (DEFAULT_PANEL == LG_WQHD_LM270WQ1)
   OD_LUT1_LM270WQ1_6MS, OD_LUT2_LM270WQ1_6MS, // Medium
   OD_LUT1_LM270WQ1_6MS_V2, OD_LUT2_LM270WQ1_6MS, // Low
   OD_LUT1_LM270WQ1_5MS, OD_LUT2_LM270WQ1_6MS, // High  
   #else
   OD_LUT1,OD_LUT2, // Medium OD_LUT1, OD_LUT2
   OD_LUT1,OD_LUT2, // Low OD_LUT1, OD_LUT2
   OD_LUT1,OD_LUT2, // High OD_LUT1, OD_LUT2
   #endif
   NULL_PTR,						// Signifies no more tables
};
#endif

//******************************************************************************
//  C O D E
//******************************************************************************

//******************************************************************************
//
// FUNCTION       : void ADCCalibration(void)
//
// USAGE          : Perform ADC Calibration and save setting into NVRAM
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvs_InputConfigTbl      (R)
//                  gmvb_InputConnector      (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void ADCCalibration(void)
{
#if FEATURE_AIP == ENABLE
   PerformAdcCalibration();         // Call adjuster function
   #ifdef DELL_U2410F
   OSDRequestMsg(CH_A, MTO_AutoColorCompleted,REQUEST_NOW); 
   #else
   OSDRequestMsg(CH_A, MTO_ADCCalibrationCompleted, REQUEST_NOW);
   #endif
#endif
}

#ifdef Action_FactoryGetADCValues_WB_Used
//******************************************************************************
//
// FUNCTION       : void FactoryGetADCValues(void)
//
// USAGE          : Get ADC values from NVRAM. This function assumes that ADC
//               calibration is just called, and main port hasn't changed yet.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void FactoryGetADCValues(void)
{
#if FEATURE_AIP == ENABLE

   gmt_ADC_SETTING AdcSettings;
   BYTE B_Channel = gmvb_MainChannel;

   switch (GetChannelConnType(B_Channel))
   {
      case COMPONENT:
         ReadAdcSettings(gmd_ADC_0, (BYTE*)&AdcSettings, ADC_SETTING_HD);
         break;

      case VGA:
         ReadAdcSettings(gmd_ADC_0, (BYTE *)&AdcSettings, ADC_SETTING_GRAPHIC);
         break;

      case TUNER:
      case COMPOSITE:
      case SVIDEO:
         break;

      default:
         break;
   };

#ifdef DELL_U2410F //KevinL 20081025 for Factory mode
   UserPrefGlobalOffset1_R= AdcSettings.AdcRedOffset1;
   UserPrefGlobalOffset1_G = AdcSettings.AdcGreenOffset1;
   UserPrefGlobalOffset1_B = AdcSettings.AdcBlueOffset1;
   UserPrefGlobalOffset2_R = AdcSettings.AdcRedOffset2;
   UserPrefGlobalOffset2_G = AdcSettings.AdcGreenOffset2;
   UserPrefGlobalOffset2_B = AdcSettings.AdcBlueOffset2;
   UserPrefGlobalGain_R= AdcSettings.AdcRedGain;
   UserPrefGlobalGain_G = AdcSettings.AdcGreenGain;
   UserPrefGlobalGain_B = AdcSettings.AdcBlueGain;	
#else   
   UserPrefOffset1_1OffsetGain = AdcSettings.AdcRedOffset1;
   UserPrefOffset1_2OffsetGain = AdcSettings.AdcGreenOffset1;
   UserPrefOffset1_3OffsetGain = AdcSettings.AdcBlueOffset1;
   UserPrefOffset2_1OffsetGain = AdcSettings.AdcRedOffset2;
   UserPrefOffset2_2OffsetGain = AdcSettings.AdcGreenOffset2;
   UserPrefOffset2_3OffsetGain = AdcSettings.AdcBlueOffset2;
   UserPrefGain_1OffsetGain = AdcSettings.AdcRedGain;
   UserPrefGain_2OffsetGain = AdcSettings.AdcGreenGain;
   UserPrefGain_3OffsetGain = AdcSettings.AdcBlueGain;
#endif      
#endif // FEATURE_AIP == ENABLE
}
#endif

#ifdef Action_FactorySaveADCValues_WB_Used
//******************************************************************************
//
// FUNCTION       : void FactorySaveADCValues(void)
//
// USAGE          : Save ADC values to NVRAM.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void FactorySaveADCValues(void)
{
#if FEATURE_AIP == ENABLE

   gmt_ADC_SETTING AdcSettings;
   BYTE B_Channel = gmvb_MainChannel;
   
#ifdef DELL_U2410F //KevinL 20081025 for Factory mode
    AdcSettings.AdcRedOffset1 = UserPrefGlobalOffset1_R;
    AdcSettings.AdcGreenOffset1 = UserPrefGlobalOffset1_G;
    AdcSettings.AdcBlueOffset1 = UserPrefGlobalOffset1_B;
    AdcSettings.AdcRedOffset2 = UserPrefGlobalOffset2_R;
    AdcSettings.AdcGreenOffset2 = UserPrefGlobalOffset2_G;
    AdcSettings.AdcBlueOffset2 = UserPrefGlobalOffset2_B;
    AdcSettings.AdcRedGain = UserPrefGlobalGain_R;
    AdcSettings.AdcGreenGain = UserPrefGlobalGain_G;
    AdcSettings.AdcBlueGain = UserPrefGlobalGain_B;		
#else		
   AdcSettings.AdcRedOffset1 = UserPrefOffset1_1OffsetGain;
   AdcSettings.AdcGreenOffset1 = UserPrefOffset1_2OffsetGain;
   AdcSettings.AdcBlueOffset1 = UserPrefOffset1_3OffsetGain;
   AdcSettings.AdcRedOffset2 = UserPrefOffset2_1OffsetGain;
   AdcSettings.AdcGreenOffset2 = UserPrefOffset2_2OffsetGain;
   AdcSettings.AdcBlueOffset2 = UserPrefOffset2_3OffsetGain;
   AdcSettings.AdcRedGain = UserPrefGain_1OffsetGain;
   AdcSettings.AdcGreenGain = UserPrefGain_2OffsetGain;
   AdcSettings.AdcBlueGain = UserPrefGain_3OffsetGain;
#endif
   //
   // Save ADC settings into NVRAM
   //
   switch (GetChannelConnType(B_Channel))
   {
      case COMPONENT:
         SaveAdcSettings(gmd_ADC_0, (BYTE *)&AdcSettings, ADC_SETTING_HD);
         break;

      case VGA:
         SaveAdcSettings(gmd_ADC_0, (BYTE *)&AdcSettings, ADC_SETTING_GRAPHIC);
         break;

      default:
         return;
   }
#endif // FEATURE_AIP == ENABLE
}
#endif

#ifdef Action_FactoryAdjustADCValues_WB_Used
//******************************************************************************
//
// FUNCTION       : void FactoryAdjustADCValues(void)
//
// USAGE          : Set ADC values to regs.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void FactoryAdjustADCValues(void)
{
#if FEATURE_AIP == ENABLE

   gmt_ADC_SETTING AdcSettings;

#ifdef DELL_U2410F //KevinL 20081025 for Factory mode
    AdcSettings.AdcRedOffset1 = UserPrefGlobalOffset1_R;
    AdcSettings.AdcGreenOffset1 = UserPrefGlobalOffset1_G;
    AdcSettings.AdcBlueOffset1 = UserPrefGlobalOffset1_B;
    AdcSettings.AdcRedOffset2 = UserPrefGlobalOffset2_R;
    AdcSettings.AdcGreenOffset2 = UserPrefGlobalOffset2_G;
    AdcSettings.AdcBlueOffset2 = UserPrefGlobalOffset2_B;
    AdcSettings.AdcRedGain = UserPrefGlobalGain_R;
    AdcSettings.AdcGreenGain = UserPrefGlobalGain_G;
    AdcSettings.AdcBlueGain = UserPrefGlobalGain_B;		
#else	   
   AdcSettings.AdcRedOffset1 = UserPrefOffset1_1OffsetGain;
   AdcSettings.AdcGreenOffset1 = UserPrefOffset1_2OffsetGain;
   AdcSettings.AdcBlueOffset1 = UserPrefOffset1_3OffsetGain;
   AdcSettings.AdcRedOffset2 = UserPrefOffset2_1OffsetGain;
   AdcSettings.AdcGreenOffset2 = UserPrefOffset2_2OffsetGain;
   AdcSettings.AdcBlueOffset2 = UserPrefOffset2_3OffsetGain;
   AdcSettings.AdcRedGain = UserPrefGain_1OffsetGain;
   AdcSettings.AdcGreenGain = UserPrefGain_2OffsetGain;
   AdcSettings.AdcBlueGain = UserPrefGain_3OffsetGain;
#endif
   //
   // Set ADC Gain and Offset values into registers
   //
   gm_SetAdcGainOffset(gmd_ADC_0, &AdcSettings);   
#endif // FEATURE_AIP == ENABLE
}
#endif


#ifdef ADJUSTER_SPLITSCREEN_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustSplitScreen(void)
//
// USAGE          :
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        :
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustSplitScreen(void)
{
   gmt_VIDEO_WIN_CONFIG select;

   if (UserPrefSplitScreen)
   {
      select = DEMO_WINDOW_SPLIT;
   }
   else
   {
      select = VIDEO_WIN_DISABLED;
   }
   gm_CscSetVideoWindow(select);
   AdjustAccAcmSplit();
#if (FEATURE_OVERDRIVE == ENABLE)
   AdjustLCDOverdrive();
#endif
}
#endif

#ifdef ADJUSTER_SPLITDIRECTION_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustSplitDirection(void)
//
// USAGE          :
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        :
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustSplitDirection(void)
{
#if defined(UserPrefSplitScreen) && defined(UserPrefSplitDirection)
   if (UserPrefSplitScreen)
      gm_CscSetVideoWindow(UserPrefSplitDirection); // Setup video window and program Set B of coefficients+offsets
   else
      gm_CscSetVideoWindow(VIDEO_WIN_DISABLED);
#endif
   msg_i ("Direction = %d",UserPrefSplitDirection);
}
#endif

#ifdef ADJUSTER_SPLITSCREEN_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustAccAcmSplit(void)
//
// USAGE          :
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        :
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustAccAcmSplit(void)
{
#if defined(UserPrefSplitScreen) && !(defined(DELL_U2410F))	// Removed by ST_hansPENG 081007
   gmt_PHY_CH B_Channel;

#if (FEATURE_CROSS_POINT_SWITCH == ENABLE)
#ifdef UserPrefColorResourceRouting
   if (UserPrefColorResourceRouting == 0)
      B_Channel = CH_A;
   else
      B_Channel = CH_B;
#endif
#else
   B_Channel = CH_A;
#endif

   if (UserPrefSplitScreen)
   {
      SETBIT (gmvw_AccAcmMode, ACC_SPLIT | ACM_SPLIT);
      //
      // Enable split feature immediately if input is video
      //
      if (IsAcmUsed()&&(gm_IsVideo(B_Channel)))
         gm_VideoProcessingAdjustment(VIDEO_ACM, ACC_ACM_INSIDE_HIGHLIGHT_WIN);
#if(!defined(ACC_LUT_METHOD))
	#ifdef DELL_U2410F	// Modeified by ST_hansPENG 081013
		if (gm_IsVideo(B_Channel))
	#else
                if ((UserPrefImageScheme != USER)&&(gm_IsVideo(B_Channel)))
	#endif
         gm_VideoProcessingAdjustment(VIDEO_ACC, ACC_ACM_INSIDE_HIGHLIGHT_WIN);
#endif
   }
   else
   {
      CLRBIT (gmvw_AccAcmMode, ACC_SPLIT | ACM_SPLIT);
      //
      // Disable split feature if it was enabled
      //
      if (IsAcmUsed()) // Graphic support ACM
         gm_VideoProcessingAdjustment (VIDEO_ACM, ACC_ACM_FULLSCREEN);
      else
      {
         gm_VideoProcessingDisable(VIDEO_ACM);
      }

#if(!defined(ACC_LUT_METHOD))
      #ifdef DELL_U2410F	// Modified by ST_hansPENG 081013
		if (gm_IsVideo(B_Channel))
      #else
      if(UserPrefImageScheme != USER) // &&(gm_IsVideo(B_Channel))) // Graphice support ACC
      #endif
         gm_VideoProcessingAdjustment (VIDEO_ACC, ACC_ACM_FULLSCREEN);
      else
      {
         if(gm_ReadRegWord(ACC_CTRL)&ACC_ENABLE)
         	gm_VideoProcessingDisable(VIDEO_ACC);
      }
#endif
   }

#endif
   //msg_i ("ACC/ACM = %d",UserPrefSplitAccAcm);
}
#endif

#ifdef ADJUSTER_SPLITLCDOVERDRIVE_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustLcdOverdriveSplit(void)
//
// USAGE          :
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        :
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustLcdOverdriveSplit(void)
{
#if (FEATURE_OVERDRIVE == ENABLE)
   if (UserPrefLCDOverdrive)
   {
#if defined(UserPrefSplitScreen)
      if (UserPrefSplitScreen)
         gm_UpdateOverDrive(OD_SPLIT, NULL_PTR, NULL_PTR); // Turn on OD for Split mode
      else
         gm_UpdateOverDrive(OD_FULL_SCREEN, NULL_PTR, NULL_PTR); // Enable OD for entire display
#endif
   }
#endif
}
#endif

#ifdef Action_FactoryFunction_WB_Used
//******************************************************************************
//
// FUNCTION       : void FactoryFunction(void)
//
// USAGE          :
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        :
//
// USED_REGS      :
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void FactoryFunction(void)
{
   gm_Print("entering Factory Password check %d",UserPrefFactoryState);
}
#endif
#ifdef Action_SetWBRegAddr_WB_Used
//******************************************************************************
//
// FUNCTION       : void SetWBRegAddr(void)
//
// USAGE          : Sets up the UserPrefRegAddr for read/write later
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void SetWBRegAddr(void)
{
   BYTE B_NibbleNum = gm_OsdGetActionByteParameter();
   switch (B_NibbleNum)
   {
      case 3:
         UserPrefRegAddr += (WORD)(32768+UserPrefScrollMenuItem*256);
         break;
      case 2:
         UserPrefRegAddr += (WORD)(UserPrefScrollMenuItem*16);
         break;
      case 1:
         UserPrefRegAddr += (WORD)(UserPrefScrollMenuItem);
         gm_Print("UserPrefRegAddr = 0x%x", UserPrefRegAddr);
         break;
      case 4:
         UserPrefRegVal += (WORD)(UserPrefScrollMenuItem*4096);
         break;
      case 5:
         UserPrefRegVal += (WORD)(UserPrefScrollMenuItem*256);
         break;
      case 6:
         UserPrefRegVal += (WORD)(UserPrefScrollMenuItem*16);
         break;
      case 7:
         UserPrefRegVal += (WORD)(UserPrefScrollMenuItem);
         gm_Print("UserPrefRegVal = 0x%x", UserPrefRegVal);
         break;
      default:
         break;
   }
}

//******************************************************************************
//
// FUNCTION       : void WBWriteReg(void)
//
// USAGE          : Register Write through WB
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void WBWriteReg(void)
{
   gm_WriteRegWord(UserPrefRegAddr, UserPrefRegVal);
}

//******************************************************************************
//
// FUNCTION       : BYTE WBReadReg(BYTE B_Nibble)
//
// USAGE          : Return a digit of the register value
//
// INPUT          : B_Nibble - nibble to read
//
// OUTPUT         : A digit of the register value
//
// GLOBALS        : UserPrefRegAddr
//                  UserPrefScrollMenuItem      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
BYTE WBReadReg(BYTE B_Nibble)
{
   BYTE B_Temp;

   switch (B_Nibble)
   {
      case 4:
         B_Temp = (gm_ReadRegWord(UserPrefRegAddr)>>12);
         break;
      case 3:
         B_Temp = ((gm_ReadRegWord(UserPrefRegAddr)>>8)& 0x0f);
         break;
      case 2:
         B_Temp = ((gm_ReadRegWord(UserPrefRegAddr)>>4) &0x0f);
         break;
      case 1:
         B_Temp = ((gm_ReadRegWord(UserPrefRegAddr))&0x0F);
         break;
      default:
         break;
   }
   return B_Temp;
}
#endif




#ifdef Action_AdjustDCDiMain_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustDCDiMain(void)
//
// USAGE          : Turn on/off DCDi for Main
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : B_ModeSetupReq      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustDCDiMain(void)
{
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif               
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_VIDEO_PROCESSING );
  	}
#endif
   ModeSetupUserPref(CH_A);
}
#endif

#ifdef Action_AdjustDCDiPip_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustDCDiPip(void)
//
// USAGE          : Turn on/off DCDi for Pip
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : B_ModeSetupReq      (R/W)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustDCDiPip(void)
{
   ModeSetupUserPref(CH_B);
}
#endif


#ifdef Action_AdjustMADI_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMADI(void)
//
// USAGE          : Setup MADI mode
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  : UserPrefMADI should have MADI mode
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMADI(void)
{
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                  
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_VIDEO_PROCESSING );
  	}
#endif
   ModeSetupUserPref(CH_A);
}
#endif


#ifdef Action_AdjustCCS_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustCCS(void)
//
// USAGE          : Setup CCS mode
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  : UserPrefCCS should have CCS mode
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustCCS(void)
{
#if (FEATURE_CCS == ENABLE)
   if ((gm_IsGraphics(CH_A)==TRUE) || (gm_IsInterlaced(CH_A)==FALSE))
      return;

#ifdef NO_CCS_ON_HD_SUPPORT
   if ( gm_IsAnyHDVideo(CH_A) == TRUE )
      return; // do nothing if NO_CCS_ON_HD_SUPPORT and HD video
#endif

   ModeSetupUserPref(CH_A);

   if (IsCCSforHDDisabled())
      gm_VideoProcessingAdjustment(VIDEO_CCS, CCS_OFF);
#endif
}
#endif

#ifdef Action_AdjustTNR_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustTNR(void)
//
// USAGE          : Setup TNR mode
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  : UserPrefTNR should have TNR mode
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustTNR(void)
{
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                     
      SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_NOISE_REDUCTION );
   }
#endif

   UserPrefTNR = UserPrefPortTNR;
   ModeSetupUserPref(CH_A);
}
#endif


#ifdef Action_AdjustSharpNoise_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustSharpNoise(void)
//
// USAGE          : Setup Sharpness Noise Coring mode
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  : UserPrefSharpNoise should have SharpNoise mode
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustSharpNoise(void)
{
#if (FEATURE_VIDEO_SHARPNOISE == REV2)
   ModeSetupUserPref(CH_A);
#endif
}
#endif


#ifdef Action_AdjustFilmMode_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustFilmMode(void)
//
// USAGE          : Adjust Film mode setting
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : B_ModeSetupReq      (R/W)
//
// USED_REGS      :
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustFilmMode(void)
{
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                        
      SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_VIDEO_PROCESSING_2 );
   }
#endif

   ModeSetupUserPref(CH_A);
}
#endif

//******************************************************************************
//
// FUNCTION       : BOOL IsOverdriveAvailable(void)
//
// USAGE          : Return if overdrive is available in current panel
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
BOOL IsOverdriveAvailable(void)
{
#if (FEATURE_OVERDRIVE == ENABLE)
   #if 1
      return TRUE; // Force return true to allow to adjust OD ...
   #else
   BYTE tbl_exists=TRUE;
   //
   // Check to see if overdrive tables exist
   //
   if (UserPrefLCDOverdrive)
   {
      //Fail-safe check
      BYTE idx=0;
      for (idx=0; idx<UserPrefLCDOverdrive; idx++)
      {
         if (PanelOverDrvLut[idx] == NULL_PTR)
         {
            msg("Error: Trying to load non-existing table");
            tbl_exists=FALSE;
            break;
         }
      }
      //Fail-safe check ends
      return tbl_exists;
   }
   //
   // When userpref is 0, show LCD Overdrive menu at least
   //
   else
   {
      return tbl_exists;
   }
   #endif
#else
   return FALSE;
#endif
}

void OverDrive_Setup(void)
{
#if (FEATURE_OVERDRIVE == ENABLE)
   if(UserPrefLCDOverdrive == 0)
   {
      gm_UpdateOverDrive(OD_OFF, 0, 0);
      msg ("LCD Overdrive Off");  
   }
   else      
   {
      //
      // Check which Overdrive table to load
      //
      if (IsOverdriveAvailable())
      {
         #if 1
         // Compress ratio: 0: 3, 1: 3.8, 2: 4.98
         gm_SetOverdriveCompressRatio(On, 1, PanelHeight, PanelWidth, On);         
         gm_UpdateOverDrive(OD_LOAD_TBL, PanelOverDrvLutDefault[(UserPrefLCDOverdrive-1)*2], PanelOverDrvLutDefault[(UserPrefLCDOverdrive-1)*2+1]);
         #else
         gm_UpdateOverDrive(OD_LOAD_TBL, (WORD ROM *) PanelOverDrvLut[UserPrefLCDOverdrive-1]);         
         #endif

         #if defined(UserPrefSplitScreen)
         if (UserPrefSplitScreen)
            gm_UpdateOverDrive(OD_SPLIT, NULL_PTR, NULL_PTR);
         else
         #endif
            gm_UpdateOverDrive(OD_FULL_SCREEN, NULL_PTR, NULL_PTR);
      }
   }
#endif  
}

#ifdef ADJUSTER_LCDOVERDRIVE_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustLCDOverdrive(void)
//
// USAGE          : Turn on/off LCD Overdrive
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustLCDOverdrive(void)
{
   #ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
      #if ENABLE_SOC_IPC_BUSY_CHECK
      /*ChengLin 20130124: New 4k2k board BUSY status check*/
      if(!SocIPCIsSlaveLeftReady())
         return;
      #endif                           
      SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_VIDEO_PROCESSING );
   }
   #endif

   OverDrive_Setup();
   
#if 0 // (FEATURE_OVERDRIVE == ENABLE)

#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                           
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_VIDEO_PROCESSING );
  	}
#endif

   if (UserPrefLCDOverdrive == 0)
   {
      gm_UpdateOverDrive(OD_OFF, 0, 0);
      msg ("LCD Overdrive Off");
   }
   else
   {
      //
      // Check which Overdrive table to load
      //
      if (IsOverdriveAvailable())
      {
#if 1
         // Compress ratio: 0: 3, 1: 3.8, 2: 4.98
         gm_SetOverdriveCompressRatio(On, 1, PanelHeight, PanelWidth, On);         
         gm_UpdateOverDrive(OD_LOAD_TBL, PanelOverDrvLutDefault[(UserPrefLCDOverdrive-1)*2], PanelOverDrvLutDefault[(UserPrefLCDOverdrive-1)*2+1]);
#else
         gm_UpdateOverDrive(OD_LOAD_TBL, (WORD ROM *) PanelOverDrvLut[UserPrefLCDOverdrive-1]);
#endif

#if defined(UserPrefSplitScreen)
         if (UserPrefSplitScreen)
            gm_UpdateOverDrive(OD_SPLIT, NULL_PTR, NULL_PTR);
         else
#endif
            gm_UpdateOverDrive(OD_FULL_SCREEN, NULL_PTR, NULL_PTR);
      }
   }
#endif
}
#endif

#ifdef Action_AdjustLCDOverdriveNoiseCoring_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustLCDOverdriveNoiseCoring(void)
//
// USAGE          : Turn on/off LCD Overdrive Noise Coring
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustLCDOverdriveNoiseCoring(void)
{
#if (FEATURE_OVERDRIVE == ENABLE)
#if defined(UserPrefLCDOverdriveNoiseCoring)
   gm_UpdateOverDriveNoiseCoring(UserPrefLCDOverdriveNoiseCoring);
#endif
#endif
}
#endif


BYTE Get_NVRAMTableIndex(void)//120816 Edward for Gamma table check move to this function
{
	if(IsPresetMode_GRAPHICS_COLOR_SPACE)
	{
		if(UserPrefPresetColorSpace == CSPACE_AdobeRGB)
			return 1;
		else if(UserPrefPresetColorSpace == CSPACE_sRGB)
			return 0;
		else if(UserPrefPresetColorSpace == CSPACE_CAL1)
			return 2;
		else
			return 3;	//CAL2			
	}
	else
			return 0;//other mode using sRGB table
}
BOOL NVRAM_TableCheck(BYTE 	Table_Type ,BYTE Table_Index)//120816 Edward for Gamma table check move to this function
{
		WORD DW_NvramAddr;

		if(Table_Type == NVRAM_Table_Gamma)
			DW_NvramAddr = C_GAMMA_COMPONENT_SAVED_START_OFFSET + (0x2000*Table_Index);
		else if(Table_Type == NVRAM_Table_DUM)
		{
			if(Table_Index == UNIFORMITY_Table1)
				DW_NvramAddr = UniformityRegisterSettingStart;
			else if(Table_Index == UNIFORMITY_Table2)
				DW_NvramAddr = UniformityRegisterSettingStart2;
			else
			{
				//gm_Print("##NVRAM DUM table index check fail -->%d",Table_Index);
				return FALSE;
			}	
		}	
		else
		{
			//gm_Print("##NVRAM table type check fail -->%d",Table_Index);
			return FALSE;
		}
		
		if((NVRam_ReadByte(DW_NvramAddr)&BIT0) && (NVRam_ReadByte(DW_NvramAddr) != 0xFF))	
		{
			//gm_Print("##NVRAM table check pass -->%d",Table_Index);
			return TRUE;
		}	
		else
		{
			//gm_Print("##NVRAM table check fail -->%d",Table_Index);
			return FALSE;
		}	
	
}

//******************************************************************************
//
// FUNCTION       : static gmt_GammaDescr ROM * ROM * GetGammaTable(void)
//
// USAGE          : Returns pointer to gamma look-up table if gamma table is defined;
//               otherwise, returns NULL_PTR
//
// INPUT          : None
//
// OUTPUT         : Pointer to gamma look-up table or NULL_PTR
//
// GLOBALS        : PanelGammaLUT
//                  UserPrefGammaTable
//
// USED_REGS      :
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
gmt_GammaDescr ROM * ROM * GetGammaTable(void)
{
   BYTE B_Count;
   BOOL Bt_Found = FALSE;
   BYTE i;
   gmt_GammaDescr ROM * ROM *ptr_GammaDescr = PanelGammaLUT;

   //gm_Printf("UserPrefColorTemp = %d", UserPrefColorTemp);
   
#if USE_NEW_GAMMA

			if(UserPrefGammaMode <= Gamma_MAC) 
				 Bt_Found = TRUE;
			else
			{
				msg_i("##Error , UserPrefGammaMode %d",UserPrefGammaMode);
				return NULL_PTR;
			}

	    if(IsPresetMode_GRAPHICS_STANDARD)
	    {
			ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode];			
	    }
		else if(IsPresetMode_GRAPHICS_MULTIMEDIA)
		{
			ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 										
	    }
		else if(IsPresetMode_GRAPHICS_MOVIE)
		{
			ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else if(IsPresetMode_GRAPHICS_GAME)
		{
	    	ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else if(IsPresetMode_GRAPHICS_TEXT)
		{
	    	ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else if(IsPresetMode_GRAPHICS_COLOR_TEMP)
		{
	    	ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else if(IsPresetMode_GRAPHICS_COLOR_SPACE)
		{
	    	ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else if(IsPresetMode_GRAPHICS_CUSTOM_COLOR)//120718 Edward add temp for PC/MAC change 
		{
	    	ptr_GammaDescr = &PanelGammaLUT[UserPrefGammaMode]; 
	    }
		else
		{
			msg_i("###no support index for gamma",0);
			Bt_Found = FALSE;
		}
		msg_i("###Get gamma table  %d",ptr_GammaDescr);
		
#else//Athena standard code


   gm_Print("##UserPrefGammaTable %d",UserPrefGammaTable);
   if(UserPrefGammaTable != GAMMA_TABLE_OFF)
   {
	   // Check if panel gamma is not NULL
	   if ((*ptr_GammaDescr) != NULL_PTR)
	   {
	      //Look for a selected gamma table until a terminator is reached
	      while ((*ptr_GammaDescr) != NULL_PTR)
	      {
	         //if(gm_ReadRegWord(IMP_CONTROL) & IMP_YUV_EN) // Check if YUV input...
	         if (gm_IsVideo(gmvb_MainChannel))
	         {
	        	#ifdef DELL_U2410F
		      	if((*ptr_GammaDescr)->B_ColorSpace == CSPACE_xvMode)		           
		  	#else	 
	             //if(((*ptr_GammaDescr)->B_ColorSpace == ColorSpace_XvYcc) &&
			      //      ((*ptr_GammaDescr)->B_ColorTemp== CTEMP_6500K))
			      if(((*ptr_GammaDescr)->B_ColorSpace == ColorSpace_XvYcc) && 
	               (IsColorWarpApply() == FALSE))
		    #endif
	            {
	               Bt_Found = TRUE;

	               // Force to xvYCC domain ...
	               if (((stInput[gmvb_MainChannel].Flags & gmd_INPUT_xvYCC_601) == 0) &&
	                     ((stInput[gmvb_MainChannel].Flags & gmd_INPUT_xvYCC_709) == 0))
	               {

	                   		//#if (NON_SCALING_OUTPUT == 0)
					#ifdef OUTPUT_MODE_CHANGE
					if(UserPrefOutputMode == OPM_Normal)
					{
                     	stInput[gmvb_MainChannel].Flags = gmd_INPUT_xvYCC_601;
              			UserPrefColorSpace = ColorSpace_XvYcc;
					}
					else
					//#else
	      				UserPrefColorSpace = ColorSpace_sRGB;
					#else
                     	stInput[gmvb_MainChannel].Flags = gmd_INPUT_xvYCC_601;
              			UserPrefColorSpace = ColorSpace_XvYcc;
					#endif
					//#endif
	                  		UserPrefColorTemp = CTEMP_6500K;
	                  //gm_Printf("~~~~ Force to xvYCC domain ...", 0);
	               }
	               //gm_Printf("Video mode load xvYCC 6500K table", 0);
	               break;
	            }
	         }
		 #if 1//Hyb 130428* Org =  def DELL_U2410F
		  	//else if((*ptr_GammaDescr)->B_ColorSpace == UserPrefPresetColorSpace) 
		 	else if((*ptr_GammaDescr)->B_ColorSpace == UserPrefGammaTable) 
		 #else
	         //else if(((*ptr_GammaDescr)->B_ColorSpace == UserPrefColorSpace) &&
	         //         ((*ptr_GammaDescr)->B_ColorTemp== UserPrefColorTemp))
	         else if((*ptr_GammaDescr)->B_ColorSpace == UserPrefColorSpace)
	        #endif          
	         {
	            //gm_Printf("UserPrefGammaTable %d", UserPrefGammaTable);
	            //gm_Printf("UserPrefColorTemp %d", UserPrefColorTemp);
	            Bt_Found = TRUE;
	            break;
	         }
	         else
	         {
	            //gm_Printf("~~~~ No Table", 0);
	         }

	         ptr_GammaDescr++;
	      }
	   }
	   else
	   {
	      //gm_Printf("~~~~ No Gamma Table ....", 0);
	   }
   }
#endif//end of DELL_U2410F

   if (Bt_Found)
   {
      gm_Printf("ptr_GammaDescr =%d", ptr_GammaDescr);
      return ptr_GammaDescr;
   }
   else
   {
   #if 0
      if (NVRAM_CHECK_FLAG)
      {
         //ModeIndependentUserPreferences = FactoryDefaultInROM;
         PortSchemeDependentUserPreferences = SchemeFactoryDefaultInROM[0];

         for (i=0; i<6; i++)
         {
            #if (FEATURE_COLORWARP == REV1)
            AdjustSixAxisColor(i);
            #else // (FEATURE_COLORWARP == REV2)
            AdjustColorWarp(i);
            #endif // (FEATURE_COLORWARP == REV1)
         }
      }
      //gm_Printf("ptr_GammaDescr not found, set to User color", ptr_GammaDescr);
      //gm_Printf("UserPrefColorSpace = %d", UserPrefColorSpace);
      //gm_Printf("UserPrefColorTemp = %d", UserPrefColorTemp);
   #endif
      return NULL_PTR;
   }
}

#if USE_NEW_GAMMA
gmt_GammaDescr ROM * ROM * GetGammaTable_ColorSpace(void)
{
	BYTE B_Count;
	BOOL Bt_Found = FALSE;
	BYTE i;
	gmt_GammaDescr ROM * ROM *ptr_GammaDescr = &Sta_GammaLUT_ColorSpace;

	if((*ptr_GammaDescr) != NULL_PTR)
	{	
	   //Look for a selected gamma table until a terminator is reached
		while((*ptr_GammaDescr) != NULL_PTR)
		{
			if(UserPrefPresetColorSpace == CSPACE_CAL1)
			{
				if((*ptr_GammaDescr)->B_ColorSpace == CSPACE_AdobeRGB)		
				{
					Bt_Found = TRUE;	
					break;
				}
			}
			else if(UserPrefPresetColorSpace == CSPACE_CAL2)
			{
				if((*ptr_GammaDescr)->B_ColorSpace == CSPACE_sRGB)				   
				{
					Bt_Found = TRUE;	
					break;
				}
			}
			else
			{
				msg_i("###no support index for gamma",0);
			}
			msg_i("###Get gamma table  %d",ptr_GammaDescr);
			ptr_GammaDescr++;
		}
	}
		
	if (Bt_Found)
	{      
		msg_i("ptr_GammaDescr =%d", ptr_GammaDescr);
		return ptr_GammaDescr;
	}
	else
	{
      return NULL_PTR;
	}
}
#else
gmt_GammaDescr ROM * ROM * GetGammaTable_ColorSpace(void)
{
	return NULL_PTR;
}
#endif

#ifdef GammaData_To_DDR
void Print_Gamma_DataInRAM(void)
{
	WORD count;
	GammaData_Structure Gamma_RAM *ptr_GammaLUTPrint;
	
	if(Get_NVRAMTableIndex() == 0)
		ptr_GammaLUTPrint = GammaLUT_sRGB;
	else if(Get_NVRAMTableIndex() == 1)
		ptr_GammaLUTPrint = GammaLUT_AdobeRGB;
	else
		return;

	for(count = 0; count < 1024; count++)
	{
		gm_Printf("Gamma %d-->0x%x",count,(BYTE far *)(ptr_GammaLUTPrint)->GammaPreLUT_R[count]);
	}
}
#endif

void AdjustGammaCorrection_PreLut(void)//For DELL firmware
{
	gmt_GammaDescr ROM * ROM *ptr_GammaDescr = GetGammaTable();
	BYTE B_Count;

	//120724 Edward for color space & gamma is PC load gamma data from NVRAM 
	#if USE_NEW_GAMMA
	if(IsPresetMode_GRAPHICS_COLOR_SPACE && (UserPrefGammaMode == Gamma_PC))
	{
		int i;
		BYTE C_Selected_Profile;
		WORD W_TableSize = 1024;
		DWORD DW_LUTAddr;
		WORD DW_NvramAddr;
		BYTE Lut_Buf[1024];
		
		C_Selected_Profile = Get_NVRAMTableIndex();

		/*if(UserPrefPresetColorSpace == CSPACE_AdobeRGB)
			C_Selected_Profile=1;
		else if(UserPrefPresetColorSpace == CSPACE_sRGB)
			C_Selected_Profile=0;
		else if(UserPrefPresetColorSpace == CSPACE_CAL1)
			C_Selected_Profile=2;
		else
			C_Selected_Profile=3;	//CAL2		
		*/	
	
		DW_LUTAddr = GAMMA_LUT_MATRIX_MULT_COEF11; // GAMMA_LUT1_CTRL;
		DW_NvramAddr = C_GAMMA_COMPONENT_SAVED_START_OFFSET + (0x2000*C_Selected_Profile);
		
		//if((NVRam_ReadByte(DW_NvramAddr)&BIT0) && (NVRam_ReadByte(DW_NvramAddr) != 0xFF))			
		if(NVRAM_TableCheck(NVRAM_Table_Gamma ,C_Selected_Profile))
		{		
			// LUT1
			for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
			{
				if(B_Count == RED_VLUT_COMPONENT)
				{
					DW_LUTAddr = INPUT_GAMMA_R_MEM_START;
					DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile);
				}
				else if(B_Count == GREEN_VLUT_COMPONENT)
				{
					DW_LUTAddr = INPUT_GAMMA_G_MEM_START;
					DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ C_ONE_CHANNEL_GAMMA_SIZE;
				}
				else if(B_Count == BLUE_VLUT_COMPONENT)
				{
					DW_LUTAddr = INPUT_GAMMA_B_MEM_START;
					DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ (C_ONE_CHANNEL_GAMMA_SIZE*2);
				}
				else if(B_Count == RED_STEEP_VLUT_COMPONENT)
				{
					W_TableSize = 128;
					DW_LUTAddr = INPUT_GAMMA_R_STEEP_MEM_START;
					DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile);
				}
				else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
				{
					W_TableSize = 128;
					DW_LUTAddr = INPUT_GAMMA_G_STEEP_MEM_START;
					DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +  C_ONE_CHANNEL_GAMMA_STEEP_SIZE;
				}
				else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
				{
					W_TableSize = 128;
					DW_LUTAddr = INPUT_GAMMA_B_STEEP_MEM_START;  
					DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +  (C_ONE_CHANNEL_GAMMA_STEEP_SIZE*2);
				}


			#ifdef GammaData_To_DDR
				if((ptr_GammaLUTInRAM->B_PreLUTLoaded == Gamma_Loaded_Flag)&&(ptr_GammaLUTInRAM != NULL_PTR))
				{					
					if(B_Count == RED_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_R,1024);
					else if(B_Count == GREEN_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_G,1024);
					else if(B_Count == BLUE_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_B,1024);
					else if(B_Count == RED_STEEP_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_R,512);
					else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_G,512);
					else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
					   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_B,512);

					//gm_Print("##write Pre LUT from DDR RAM %d",B_Count);	
				}
				else
			#endif
			  {				
				if(W_TableSize == 128)
					NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 256);
				else
					NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 1024);				
				 
				for(i = 0; i < W_TableSize; i++)
				{                     
					if(W_TableSize == 128)
					{                           
						*LINEAR_TO_FPTR_W(DW_LUTAddr) = Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8 ;
						DW_LUTAddr += 4;
						DW_NvramAddr += 2;
					}
					else
					{    						
						*LINEAR_TO_FPTR_B(DW_LUTAddr) = Lut_Buf[i];
						DW_LUTAddr += 1;
						DW_NvramAddr += 1;						
					}                                                                       
				}

				//gm_Print("##write Pre LUT from NVRAM %d",B_Count);	
			  }
			
			
			#ifdef GammaData_To_DDR
				if((ptr_GammaLUTInRAM->B_PreLUTLoaded != Gamma_Loaded_Flag)&&(ptr_GammaLUTInRAM != NULL_PTR))
				{
					if(B_Count == RED_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_R,LINEAR_TO_FPTR_B(INPUT_GAMMA_R_MEM_START),1024);
					}
					else if(B_Count == GREEN_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_G,LINEAR_TO_FPTR_B(INPUT_GAMMA_G_MEM_START),1024);
					}	
					else if(B_Count == BLUE_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUT_B,LINEAR_TO_FPTR_B(INPUT_GAMMA_B_MEM_START),1024);
					}	
					else if(B_Count == RED_STEEP_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_R,LINEAR_TO_FPTR_B(INPUT_GAMMA_R_STEEP_MEM_START),512);
					}	
					else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_G,LINEAR_TO_FPTR_B(INPUT_GAMMA_G_STEEP_MEM_START),512);
					}	
					else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
					{
					_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPreLUTSteep_B,LINEAR_TO_FPTR_B(INPUT_GAMMA_B_STEEP_MEM_START),512);
					
						ptr_GammaLUTInRAM->B_PreLUTLoaded = Gamma_Loaded_Flag;						
						//gm_Print("##save Pre LUT to RAM 0x%x",ptr_GammaLUTInRAM->B_PreLUTLoaded);
					}	
				}	
			#endif
			
				
		  		 #if 0//120801 Edward disable and move enable out site for avoid image gamma apply delay from read NVRAM
				if(((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0) && (B_Count < 3))
						gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);	
				#endif
   			}

			{
				#if 0//120801 Edward disable and move enable out site for avoid image gamma apply delay from read NVRAM
   				DW_NvramAddr = C_PRE_LUT_CONFIG_REG_START_OFFSET + (0x2000*C_Selected_Profile);
				gm_WriteRegWord(GAMMA_LUT1_CTRL, NVRam_ReadWORD(DW_NvramAddr));
				
				gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
				#endif
	   
   				DW_NvramAddr = C_PRE_LUT_CONFIG_REG_START_OFFSET + (0x2000*C_Selected_Profile);
				DW_NvramAddr += 2;
				DW_LUTAddr = GAMMA_LUT1_STEEP_STRT_R;			 
	
				NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 24);
	
				for(i = 0; i < 12; i++)
				{
					gm_WriteRegWord(DW_LUTAddr, Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8 );
					DW_LUTAddr += 2;
					DW_NvramAddr += 2;			 
				}		  
			}
		}
		//gm_Print("##Color space mode NVRAM load Pre LUT -->%d",C_Selected_Profile);
	}
	else
	#endif		
	{
		 if (ptr_GammaDescr != NULL_PTR)
   		{
      		WORD far * ptr_GammaTable;

			// LUT1
      		for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
      		{
		 		WORD W_TableSize = 512;

         		ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLut1[B_Count];
         
		 		// Update Steep
		 		if(B_Count > BLUE_VLUT_COMPONENT)
		 		{
		 			W_TableSize = 128;
            		ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLUT1Steep[B_Count-3];            
		 		}
		 
         		if(ptr_GammaTable)
	    		{
            		if(((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0) && (B_Count < 3))
            		{
               			gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
            		}
            		gm_LoadImpVlutTable(B_Count, 0, W_TableSize, ptr_GammaTable, 0);
	    		}
	    		else
	    		{
            		//gm_Printf("~~~~ No Gamma LUT1 Table ... %d", B_Count);
         		}            
      		}    

      		//gm_Printf("~~~~ B_GammaLUT1_SteepEnable = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepEnable);

      		if((*ptr_GammaDescr)->B_GammaLUT1_SteepEnable)
      		{
         		//gm_Printf("~~~~ SteepStep = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepStep);
         		gm_ClearAndSetBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_STEEP_ST, GAMMA_LUT1_STEEP_CT|((*ptr_GammaDescr)->B_GammaLUT1_SteepStep << 12));
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_END_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_R, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[0]);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_END_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_G, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[1]);         
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_END_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         		gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_B, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[2]);         
      		}
			//gm_Print("##other mode NVRAM load Pre LUT -->%d",UserPrefGraphicsImageMode);
		 }	
	}


	 // Need to add final entry
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_R, 0x4000);
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_G, 0x4000);
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_B, 0x4000);
    #if 0//120803 Edward use update from outsite of this function
	gm_WaitDisplayBlanking(CH_A);		//Neil120801+ for update in blanking to reduce garbage
	gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
    #endif
}

#ifdef USE_GAMMMA_TABLE_FROM_NVRAM
void AdjustGammaCorrection_NVRAM(void)//For DELL firmware
{
   BYTE B_Count;

	int i;
	BYTE C_Selected_Profile;
	WORD W_TableSize = 1024;
	DWORD DW_LUTAddr;
	WORD DW_NvramAddr;
	BYTE Lut_Buf[1024];
		
	C_Selected_Profile = Get_NVRAMTableIndex();

	/*if(UserPrefPresetColorSpace == CSPACE_AdobeRGB)
		C_Selected_Profile=1;
	else if(UserPrefPresetColorSpace == CSPACE_sRGB)
		C_Selected_Profile=0;
	else if(UserPrefPresetColorSpace == CSPACE_CAL1)
			C_Selected_Profile=2;
		else
			C_Selected_Profile=3;	//CAL2		
		*/	
	
	//gm_Print("T1 %d",gm_GetSystemTime());
#if 1//120724 Edward add for adjust pre lut for all
	AdjustGammaCorrection_PreLut();
#else
   	// LUT1
	for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
	{
		if(B_Count == RED_VLUT_COMPONENT)
		{
			DW_LUTAddr = INPUT_GAMMA_R_MEM_START;
			DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile);
		}
		else if(B_Count == GREEN_VLUT_COMPONENT)
		{
			DW_LUTAddr = INPUT_GAMMA_G_MEM_START;
			DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ C_ONE_CHANNEL_GAMMA_SIZE;
		}
		else if(B_Count == BLUE_VLUT_COMPONENT)
		{
			DW_LUTAddr = INPUT_GAMMA_B_MEM_START;
			DW_NvramAddr = C_PRE_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ (C_ONE_CHANNEL_GAMMA_SIZE*2);
		}
		else if(B_Count == RED_STEEP_VLUT_COMPONENT)
		{
			W_TableSize = 128;
			DW_LUTAddr = INPUT_GAMMA_R_STEEP_MEM_START;
			DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile);
		}
		else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
		{
			W_TableSize = 128;
			DW_LUTAddr = INPUT_GAMMA_G_STEEP_MEM_START;
			DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +  C_ONE_CHANNEL_GAMMA_STEEP_SIZE;
		}
		else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
		{
			W_TableSize = 128;
			DW_LUTAddr = INPUT_GAMMA_B_STEEP_MEM_START;  
			DW_NvramAddr = C_PRE_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +  (C_ONE_CHANNEL_GAMMA_STEEP_SIZE*2);
		}
			
			
		if(W_TableSize == 128)
			NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 256);
		else
		    NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 1024);
		
		for(i = 0; i < W_TableSize; i++)
		{                     
			if(W_TableSize == 128)
			{                           
				*LINEAR_TO_FPTR_W(DW_LUTAddr) = Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8 ;
				DW_LUTAddr += 4;
				DW_NvramAddr += 2;
			}
			else
			{                           
				*LINEAR_TO_FPTR_B(DW_LUTAddr) = Lut_Buf[i];
				DW_LUTAddr += 1;
				DW_NvramAddr += 1;
			}                                                                       
		}
		  
		{
			if(((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0) && (B_Count < 3))
			{
				gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
			}
		} 		   
   	}

   // Need to add final entry
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_R, 0x4000);
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_G, 0x4000);
	gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_B, 0x4000);


	{
   		DW_NvramAddr = C_PRE_LUT_CONFIG_REG_START_OFFSET + (0x2000*C_Selected_Profile);
		gm_WriteRegWord(GAMMA_LUT1_CTRL, NVRam_ReadWORD(DW_NvramAddr));
		gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
		//gm_Print("DW_NvramAddr %x= %x",DW_NvramAddr,(NVRam_ReadWORD(DW_NvramAddr)));
		//gm_Print("GAMMA_LUT1_CTRL %x= %x",GAMMA_LUT1_CTRL,(gm_ReadRegWord(GAMMA_LUT1_CTRL)));
	   
		DW_NvramAddr += 2;
		DW_LUTAddr = GAMMA_LUT1_STEEP_STRT_R;			 
	
		NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 24);
	
		for(i = 0; i < 12; i++)
		{
			gm_WriteRegWord(DW_LUTAddr, Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8 );
			DW_LUTAddr += 2;
			DW_NvramAddr += 2;			 
		}		  
	}
#endif 

   // LUT2
   W_TableSize = 1024;
   for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
   {
	   if(B_Count == RED_VLUT_COMPONENT)
	   {
		   DW_LUTAddr = OUTPUT_GAMMA_R_MEM_START;
		   DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*C_Selected_Profile);
	   }
	   else if(B_Count == GREEN_VLUT_COMPONENT)
	   {
		   DW_LUTAddr = OUTPUT_GAMMA_G_MEM_START;
		   DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ C_ONE_CHANNEL_GAMMA_SIZE;
	   }
	   else if(B_Count == BLUE_VLUT_COMPONENT)
	   {
		   DW_LUTAddr = OUTPUT_GAMMA_B_MEM_START;
		   DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*C_Selected_Profile)+ (C_ONE_CHANNEL_GAMMA_SIZE*2);
	   }
	   else if(B_Count == RED_STEEP_VLUT_COMPONENT)
	   {
		   W_TableSize = 128;
		   DW_LUTAddr = OUTPUT_GAMMA_R_STEEP_MEM_START;
		   DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*C_Selected_Profile);
	   }
	   else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
	   {
		   W_TableSize = 128;
		   DW_LUTAddr = OUTPUT_GAMMA_G_STEEP_MEM_START;
		   DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +	C_ONE_CHANNEL_GAMMA_STEEP_SIZE;
	   }
	   else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
	   {
		   W_TableSize = 128;
		   DW_LUTAddr = OUTPUT_GAMMA_B_STEEP_MEM_START;	
		   DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*C_Selected_Profile) +	(C_ONE_CHANNEL_GAMMA_STEEP_SIZE*2);
	   }

	   #ifdef GammaData_To_DDR
			if((ptr_GammaLUTInRAM->B_PostLUTLoaded == Gamma_Loaded_Flag)&&(ptr_GammaLUTInRAM != NULL_PTR))
			{					
				if(B_Count == RED_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_R,1024);
				else if(B_Count == GREEN_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_G,1024);
				else if(B_Count == BLUE_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_B,1024);
				else if(B_Count == RED_STEEP_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_R,512);
				else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_G,512);
				else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
				   _fmemcpy(LINEAR_TO_FPTR_B(DW_LUTAddr),(BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_B,512);

					//gm_Print("##write Post LUT from DDR RAM %d",B_Count);	
			}
			else
	  #endif
			{
	   			if(W_TableSize == 128)
		   			NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 256);
	   			else
		   			NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 1024);
	   
	  			for(i = 0; i < W_TableSize; i++)
	   			{					 
		  			if(W_TableSize == 128)
		  			{ 						  
			 			*LINEAR_TO_FPTR_W(DW_LUTAddr) = Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8;
			 			DW_LUTAddr += 4;
			 			DW_NvramAddr += 2;
		  			}
		  			else
		  			{ 						  
			 			*LINEAR_TO_FPTR_B(DW_LUTAddr) = Lut_Buf[i];
			 			DW_LUTAddr += 1;
			 			DW_NvramAddr += 1;
		  			} 																	  
	   			}
				
				//gm_Print("##write Post LUT from NVRAM %d",B_Count);	
			}
	  
	 	#ifdef GammaData_To_DDR
			if((ptr_GammaLUTInRAM->B_PostLUTLoaded != Gamma_Loaded_Flag)&&(ptr_GammaLUTInRAM != NULL_PTR))
			{
				if(B_Count == RED_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_R,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_R_MEM_START),1024);
				}
				else if(B_Count == GREEN_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_G,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_G_MEM_START),1024);
				}	
				else if(B_Count == BLUE_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUT_B,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_B_MEM_START),1024);
				}	
				else if(B_Count == RED_STEEP_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_R,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_R_STEEP_MEM_START),512);
				}	
				else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_G,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_G_STEEP_MEM_START),512);
				}	
				else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
				{
				_fmemcpy((BYTE far *)(ptr_GammaLUTInRAM)->GammaPostLUTSteep_B,LINEAR_TO_FPTR_B(OUTPUT_GAMMA_B_STEEP_MEM_START),512);
				
					ptr_GammaLUTInRAM->B_PostLUTLoaded = Gamma_Loaded_Flag;						
					gm_Print("##save Post LUT to RAM 0x%x",ptr_GammaLUTInRAM->B_PostLUTLoaded);
				}	
			}	
		#endif
		
		#if 0//120801 Edward disable and move enable out site for avoid image gamma apply delay from read NVRAM
	   {
		   if(((gm_ReadRegWord(GAMMA_LUT2_CTRL)&GAMMA_LUT2_CTL) == 0) && (B_Count < 3))
		   {
			   gm_SetRegBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_CTL);
		   }
	   }
		#endif
   }
   
	 
   // Need to add final entry
   gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_R, 0x4000);
   gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_G, 0x4000);
   gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_B, 0x4000);


   {
   	 #if 0//120801 Edward disable and move enable out site for avoid image gamma apply delay from read NVRAM
	   DW_NvramAddr = C_POST_LUT_CONFIG_REG_START_OFFSET+ (0x2000*C_Selected_Profile);
	   gm_WriteRegWord(GAMMA_LUT2_CTRL, NVRam_ReadWORD(DW_NvramAddr));
	 #endif  
	  
	   DW_NvramAddr = C_POST_LUT_CONFIG_REG_START_OFFSET+ (0x2000*C_Selected_Profile);
	   DW_NvramAddr += 2;
	   DW_LUTAddr = GAMMA_LUT2_STEEP_STRT_R;			
   

	   NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 24);
   
	   for(i = 0; i < 12; i++)
	   {
		   gm_WriteRegWord(DW_LUTAddr, Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8);
		   DW_LUTAddr += 2;
		   DW_NvramAddr += 2;			
	   }		 
   }

   //gm_Print("T2 %d",gm_GetSystemTime());

   //gm_WriteRegWord (DISP_LUT_CONTROL, DISP_LUT_WINDOW_TYPE); // sRGB, Dither, OD need to set the window
   gm_WriteRegWord (DISP_LUT_CONTROL, BIT0|BIT1); // sRGB, Dither, OD need to set the window for main only ...

   #if (FEATURE_DITHER == ENABLE)
   Dither_UploadDitherTable(); // Always run dither ...
   #endif

   #if (FEATURE_DUM == ENABLE)
   	#if defined(SAVING_DATA_INTO_FLASH) || defined(SAVING_DATA_INTO_NVRAM) // Flash data saving 	 
   	// load dum at init.c from flash data
   		//120807 Edward add for load uniformity by preset mode
   		if(IS_UNIFORMITY_GrayOut && IS_UNIFORMITY_ON())//make sure the uniformity is set off
			UserPrefDUMSwitch = UNIFORMITY_OFF;
		
		DisplayUniformityModule(UserPrefDUMSwitch, FALSE, 1, 1, PanelWidth, PanelHeight);				
   	#else
   		DisplayUniformityModule(FALSE, FALSE, 1, 1, PanelWidth, PanelHeight);
   	#endif
   #endif
   
}

#endif // end if USE_GAMMMA_TABLE_FROM_NVRAM


#ifdef ADJUSTER_GAMMATABLE_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustGammaCorrection(void)
//
// USAGE          : Select Gamma: Off/On for output gamma tables.
//                  Each color (RGB) has a separate gamma correction table.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel
//                  UserPrefGammaTable
//                  TempBuffer[]
//
// USED_REGS      : DISP_LUT_CONTROL       (R/W)
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustGammaCorrection(void)
{
   BYTE B_Count;
   BYTE Table_Index;
   
   gmt_GammaDescr ROM * ROM *ptr_GammaDescr = GetGammaTable();
   
   #ifdef NonColorSpacePostLUT_FROM_NVRAM //120817 Edward add for color team request
   Table_Index = Get_NVRAMTableIndex();
   #endif

   if (ptr_GammaDescr != NULL_PTR)
   {
      WORD far * ptr_GammaTable;

	
#if 1//120724 Edward add for adjust pre lut for all
		AdjustGammaCorrection_PreLut();
#else
	
      // LUT1
      for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
      {
         WORD W_TableSize = 512;

         ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLut1[B_Count];

         // Update Steep
         if (B_Count > BLUE_VLUT_COMPONENT)
         {
            W_TableSize = 128;
            ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLUT1Steep[B_Count-3];
         }

         if (ptr_GammaTable)
         {
            if (((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0) && (B_Count < 3))
            {
               gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
            }
            gm_LoadImpVlutTable(B_Count, 0, W_TableSize, ptr_GammaTable, 0);
         }
         else
         {
            //gm_Printf("~~~~ No Gamma LUT1 Table ... %d", B_Count);
         }
      }

      // Need to add final entry
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_R, 0x4000);
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_G, 0x4000);
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_B, 0x4000);

      //gm_Printf("~~~~ B_GammaLUT1_SteepEnable = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepEnable);

      if ((*ptr_GammaDescr)->B_GammaLUT1_SteepEnable)
      {
         //gm_Printf("~~~~ SteepStep = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepStep);
         gm_ClearAndSetBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_STEEP_ST, GAMMA_LUT1_STEEP_CT|((*ptr_GammaDescr)->B_GammaLUT1_SteepStep << 12));
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_R, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[0]);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_G, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[1]);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_B, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[2]);
      }
	#endif

	
#ifdef NonColorSpacePostLUT_FROM_NVRAM //120817 Edward add for color team request
      // LUT2
      if(NVRAM_TableCheck(NVRAM_Table_Gamma,Table_Index))//120817 Edward 
      {
      		int i;
			WORD W_TableSize;
			DWORD DW_LUTAddr;
			WORD DW_NvramAddr;
			BYTE Lut_Buf[1024];

		 //120817 Edward load sRGB post lut as default for non color Space mode , to avoid load every time
		 if(!NonColorSpaceGammaPostLUT_Loaded)
		 {
      		W_TableSize = 1024;
   			for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
   			{
	   			if(B_Count == RED_VLUT_COMPONENT)
	   			{
		   			DW_LUTAddr = OUTPUT_GAMMA_R_MEM_START;
		   			DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*Table_Index);
	   			}
	   			else if(B_Count == GREEN_VLUT_COMPONENT)
	   			{
		   			DW_LUTAddr = OUTPUT_GAMMA_G_MEM_START;
		   			DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*Table_Index)+ C_ONE_CHANNEL_GAMMA_SIZE;
	   			}
	   			else if(B_Count == BLUE_VLUT_COMPONENT)
	   			{
		   			DW_LUTAddr = OUTPUT_GAMMA_B_MEM_START;
		   			DW_NvramAddr = C_POST_LUT_START_OFFSET + (0x2000*Table_Index)+ (C_ONE_CHANNEL_GAMMA_SIZE*2);
	   			}
	   			else if(B_Count == RED_STEEP_VLUT_COMPONENT)
	   			{
		   			W_TableSize = 128;
		   			DW_LUTAddr = OUTPUT_GAMMA_R_STEEP_MEM_START;
		   			DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*Table_Index);
	   			}
	   			else if(B_Count == GREEN_STEEP_VLUT_COMPONENT)
	   			{
		   			W_TableSize = 128;
		   			DW_LUTAddr = OUTPUT_GAMMA_G_STEEP_MEM_START;
		   			DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*Table_Index)+C_ONE_CHANNEL_GAMMA_STEEP_SIZE;
	   			}
	   			else if(B_Count == BLUE_STEEP_VLUT_COMPONENT)
	   			{
		   			W_TableSize = 128;
		   			DW_LUTAddr = OUTPUT_GAMMA_B_STEEP_MEM_START;	
		   			DW_NvramAddr = C_POST_STEEP_START_OFFSET + (0x2000*Table_Index)+(C_ONE_CHANNEL_GAMMA_STEEP_SIZE*2);
	   			}
	   
	   		if(W_TableSize == 128)
		   		NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 256);
	   		else
		   		NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 1024);
	   
	   		for(i = 0; i < W_TableSize; i++)
	   		{					 
		  		if(W_TableSize == 128)
		  		{ 						  
			 		*LINEAR_TO_FPTR_W(DW_LUTAddr) = Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8;
			 		DW_LUTAddr += 4;
			 		DW_NvramAddr += 2;
		  		}
		  		else
		  		{ 						  
			 		*LINEAR_TO_FPTR_B(DW_LUTAddr) = Lut_Buf[i];
			 		DW_LUTAddr += 1;
			 		DW_NvramAddr += 1;
		  		} 																	  
	   		}	 
		
  		 }
			
			// Need to add final entry
      		gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_R, 0x4000);
      		gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_G, 0x4000);
      		gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_B, 0x4000);

			//Gamma steep table
		 	{
				DW_NvramAddr = C_POST_LUT_CONFIG_REG_START_OFFSET+ (0x2000*Table_Index);
	   			DW_NvramAddr += 2;
	   			DW_LUTAddr = GAMMA_LUT2_STEEP_STRT_R;			
   
	   			NVRam_ReadBuffer(DW_NvramAddr, Lut_Buf, 24);
   
	   			for(i = 0; i < 12; i++)
	   			{
		   			gm_WriteRegWord(DW_LUTAddr, Lut_Buf[i*2]|Lut_Buf[i*2+1]<<8);
		   			DW_LUTAddr += 2;
		   			DW_NvramAddr += 2;			
	   			}		 
   			}
	   		DW_NvramAddr = C_POST_LUT_CONFIG_REG_START_OFFSET+ (0x2000*Table_Index);
	   		gm_WriteRegWord(GAMMA_LUT2_CTRL, NVRam_ReadWORD(DW_NvramAddr));

			//gm_Print("##~~sRGB gamma table loaded from NVRAM",0);
		}	
      }
	  else//no data in table load firmware default table
	#endif	  
      {
      	//load post lut from code
      	//120817 Edward load sRGB post lut as default for non color Space mode , to avoid load every time
		if(!NonColorSpaceGammaPostLUT_Loaded)
		 {
		 	//gm_Print("##Load gamma",0);
      		for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
      		{
         		WORD W_TableSize = 512;         

         		ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLut2[B_Count];
					
		   		// Update Steep
		   		if(B_Count > BLUE_VLUT_COMPONENT)
         		{
            		W_TableSize = 128;
            		ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLUT2Steep[B_Count-3];            
	    		}

         		if(ptr_GammaTable)
         		{
            		if(((gm_ReadRegWord(GAMMA_LUT2_CTRL)&GAMMA_LUT2_CTL) == 0) && (B_Count < 3))
					{
               			gm_SetRegBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_CTL);
            		}         
            		gm_LoadVlutTable(B_Count, 0, W_TableSize, ptr_GammaTable, 0);
				}
				else
				{
            		gm_Printf("~~~~ No Gamma LUT2 Table ... %d", B_Count);
         		}            
			}
      	
      			// Need to add final entry
      			gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_R, 0x4000);
      			gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_G, 0x4000);
      			gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_B, 0x4000);

      			//gm_Printf("~~~~ B_GammaLUT2_SteepEnable = %d ...", (*ptr_GammaDescr)->B_GammaLUT2_SteepEnable);

      			if((*ptr_GammaDescr)->B_GammaLUT2_SteepEnable)
				{
         			//gm_Printf("~~~~ 2 SteepStep = %d ...", (*ptr_GammaDescr)->B_GammaLUT2_SteepStep);
         			gm_ClearAndSetBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_STEEP_ST, GAMMA_LUT2_STEEP_CT|((*ptr_GammaDescr)->B_GammaLUT2_SteepStep << 8));
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_R, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_END_R, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_R, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[0]);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_G, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_END_G, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_G, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[1]);         
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_B, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_END_B, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         			gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_B, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[2]);         
				}
			}
		 	else
		 		{
		 			//gm_Print("##Gamma already loaded",0);
		 		}	
	  }
   }
   else
   {
      // Disable Gamma LUT Table
      gm_ClearRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
      gm_ClearRegBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_CTL|GAMMA_LUT2_STEEP_CT);
    }

   //gm_WriteRegWord (DISP_LUT_CONTROL, DISP_LUT_WINDOW_TYPE); // sRGB, Dither, OD need to set the window
   gm_WriteRegWord (DISP_LUT_CONTROL, BIT0|BIT1); // sRGB, Dither, OD need to set the window for main only ...

   #if (FEATURE_DITHER == ENABLE)
   Dither_UploadDitherTable(); // Always run dither ...
   #endif

   #if 0//(FEATURE_DUM == ENABLE)	//yvonne 20120920 for DUM not load while change preset mode not tick 
	#if defined(SAVING_DATA_INTO_FLASH) || defined(SAVING_DATA_INTO_NVRAM) // Flash data saving 	 
   	// load dum at init.c from flash data
   		//120807 Edward add for load uniformity by preset mode
   		if(IS_UNIFORMITY_GrayOut && IS_UNIFORMITY_ON())//make sure the uniformity is set off
			UserPrefDUMSwitch = UNIFORMITY_OFF;
		
		DisplayUniformityModule(UserPrefDUMSwitch, FALSE, 1, 1, PanelWidth, PanelHeight);
   	#else
   		DisplayUniformityModule(FALSE, FALSE, 1, 1, PanelWidth, PanelHeight);
   	#endif
   #endif

    #if 1//120928 Edward to avoid garbage
		if(gm_WaitDisplayBlanking_CH(CH_A)) //KevinL 20120923 force update on blanking period immediatelly 
			gm_ForceUpdate(gmvb_MainChannel, OUTPUT_CLOCK);	
		else
			gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
	#else
		gm_WaitDisplayBlanking(CH_A);		//Neil120801+ for update in blanking to reduce garbage
		gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);  
	#endif
}
#endif


#ifdef ADJUSTER_GAMMAMODE_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustGammaMode(void)
//
// USAGE          : Select Gamma: Gamma mode for MAC / PC.  //                 
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : DISP_LUT_CONTROL       (R/W)
//
// PRE_CONDITION  : 
//
// POST_CONDITION : 
//
//******************************************************************************

void AdjustGammaMode(void)//120806 Edward for PC/MAC adjust
{
	AdjustGammaCorrection_PreLut();//change pre lut only
	
	//enable gamma control
	if(IsPresetMode_GRAPHICS_COLOR_SPACE && (UserPrefGammaMode == Gamma_PC))
	{
		BYTE C_Selected_Profile;
		WORD DW_NvramAddr;	
		
		C_Selected_Profile = Get_NVRAMTableIndex();
		
		/*if(UserPrefPresetColorSpace == CSPACE_AdobeRGB)
			C_Selected_Profile=1;
		else if(UserPrefPresetColorSpace == CSPACE_sRGB)
			C_Selected_Profile=0;
		else if(UserPrefPresetColorSpace == CSPACE_CAL1)
			C_Selected_Profile=2;
		else
			C_Selected_Profile=3;	//CAL2			
		*/
		
		DW_NvramAddr = C_GAMMA_COMPONENT_SAVED_START_OFFSET + (0x2000*C_Selected_Profile);
		
		//if((NVRam_ReadByte(DW_NvramAddr)&BIT0) && (NVRam_ReadByte(DW_NvramAddr) != 0xFF))		
		if(NVRAM_TableCheck(NVRAM_Table_Gamma,C_Selected_Profile))
		{
			DW_NvramAddr = C_PRE_LUT_CONFIG_REG_START_OFFSET + (0x2000*C_Selected_Profile);
			gm_WriteRegWord(GAMMA_LUT1_CTRL, NVRam_ReadWORD(DW_NvramAddr));	

			#if 1//120928 Edward to avoid garbage
			if(gm_WaitDisplayBlanking_CH(CH_A)) //KevinL 20120923 force update on blanking period immediatelly 
				gm_ForceUpdate(gmvb_MainChannel, OUTPUT_CLOCK);	
			else
				gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
			#else
				gm_WaitDisplayBlanking(CH_A);		//Neil120801+ for update in blanking to reduce garbage
				gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
			#endif
		}	
	}
	else
	{
		if((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0)
		{
			gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);	
			#if 1
				if(gm_WaitDisplayBlanking_CH(CH_A)) //KevinL 20120923 force update on blanking period immediatelly 
					gm_ForceUpdate(gmvb_MainChannel, OUTPUT_CLOCK);	
				else
					gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
			#else
				gm_WaitDisplayBlanking(CH_A);		//Neil120801+ for update in blanking to reduce garbage
				gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
			#endif
		}	
	}
	
	
}
#endif


#ifdef DELL_U2410F
#define ODP_CSC_BLOCK_START GAMMA_LUT_MATRIX_MULT_COEF11

#define COEF_11		0x0000
#define COEF_12	 	0x0002	
#define COEF_13	 	0x0004	
#define COEF_21	 	0x0006	
#define COEF_22 		0x0008	
#define COEF_23 		0x000A	
#define COEF_31	 	0x000C	
#define COEF_32 		0x000E	
#define COEF_33 		0x0010	
#define OFFSET1	 	0x0012	
#define OFFSET2 		0x0014	
#define OFFSET3 		0x0016

static void CheckSignNum_c(SDWORD *InMatx)
{
	BYTE i;
	
	for (i=0;i<9;i++)
	{
		if (InMatx[i] & BIT13)	/// nagtive number
			{
				InMatx[i] |= 0xFFFFE000;
			}
	}
}

// 20081020 #1, for XvYcc remapping
static void __near matrix_MxM_c(SDWORD *A, SDWORD *B)
{
	BYTE row,col;
	SDWORD M[3][3];
	SDWORD a,b,c;

    for(row=0;row<3;row++)
    {
		for(col=0;col<3;col++)
        {
			a = A[row * 3 + 0] * B[0 * 3 + col];
			b = A[row * 3 + 1] * B[1 * 3 + col];
            		c = A[row * 3 + 2] * B[2 * 3 + col];
			M[row][col] = (a + b + c) >> 10;
			//M[row][col] = (a + b + c) >> 8;
		}
	}
	memcpy(A,M,sizeof(M));
}

#if USE_NEW_GAMMA
void AdjustGammaCorrection_ColorSpace(void)
{
   BYTE B_Count;

   gmt_GammaDescr ROM * ROM *ptr_GammaDescr =GetGammaTable_ColorSpace();
   
   
	  // ODP 3x3 matrix update for color space
	  {
		 WORD W_Addr;
		 SDWORD rgbGain[3][3] = {{0x400,0,0}, {0,0x400,0}, {0,0,0x400}};
		 SDWORD *ccMatrix;
		 BOOL UpdateFalag;
		 SDWORD sRGB[3][3] = {{1024,0,0}, {0,1024,0}, {0,0,1024}};
	   
		 CheckSignNum_c(&rgbGain[0][0]);

		 if(ptr_GammaDescr)
		 {
			sRGB[0][0] = (*ptr_GammaDescr)->Wp_3x3Values[4]; // G2
			sRGB[0][1] = (*ptr_GammaDescr)->Wp_3x3Values[7]; // G3
			sRGB[0][2] = (*ptr_GammaDescr)->Wp_3x3Values[1]; // G1
			sRGB[1][0] = (*ptr_GammaDescr)->Wp_3x3Values[5]; // B2
			sRGB[1][1] = (*ptr_GammaDescr)->Wp_3x3Values[8]; // B3
			sRGB[1][2] = (*ptr_GammaDescr)->Wp_3x3Values[2]; // B1
			sRGB[2][0] = (*ptr_GammaDescr)->Wp_3x3Values[3]; // R2
			sRGB[2][1] = (*ptr_GammaDescr)->Wp_3x3Values[6]; // R3
			sRGB[2][2] = (*ptr_GammaDescr)->Wp_3x3Values[0]; // R1								  
		 }
		 else
		 {
			sRGB[0][0] = 0x400;
			sRGB[1][1] = 0x400;
			sRGB[2][2] = 0x400;
		 }		
   
		 ccMatrix = &sRGB[0][0];
   
   #ifdef _DEBUG
		 gm_Print("sYUVRGB 0 .................. 0x%x", ccMatrix[0]);
		 gm_Print("sYUVRGB 1 .................. 0x%x", ccMatrix[1]);
		 gm_Print("sYUVRGB 2 .................. 0x%x", ccMatrix[2]);
		 gm_Print("sYUVRGB 3 .................. 0x%x", ccMatrix[3]);
		 gm_Print("sYUVRGB 4 .................. 0x%x", ccMatrix[4]);
		 gm_Print("sYUVRGB 5 .................. 0x%x", ccMatrix[5]);
		 gm_Print("sYUVRGB 6 .................. 0x%x", ccMatrix[6]);
		 gm_Print("sYUVRGB 7 .................. 0x%x", ccMatrix[7]);
		 gm_Print("sYUVRGB 8 .................. 0x%x", ccMatrix[8]);
	#endif
   
		 // B = YUV coef
		 // A = xvYCC tbl
		 //matrix_MxM(&rgbGain[0][0],ccMatrix);
		 matrix_MxM_c(ccMatrix, &rgbGain[0][0]);
   
   #ifdef _DEBUG
		 gm_Print("ccMatrix 0 .................. 0x%x", ccMatrix[0]);
		 gm_Print("ccMatrix 1 .................. 0x%x", ccMatrix[1]);
		 gm_Print("ccMatrix 2 .................. 0x%x", ccMatrix[2]);
		 gm_Print("ccMatrix 3 .................. 0x%x", ccMatrix[3]);
		 gm_Print("ccMatrix 4 .................. 0x%x", ccMatrix[4]);
		 gm_Print("ccMatrix 5 .................. 0x%x", ccMatrix[5]);
		 gm_Print("ccMatrix 6 .................. 0x%x", ccMatrix[6]);
		 gm_Print("ccMatrix 7 .................. 0x%x", ccMatrix[7]);
		 gm_Print("ccMatrix 8 .................. 0x%x", ccMatrix[8]);
	#endif
   
		 W_Addr = ODP_CSC_BLOCK_START;
   
		 // GAMMA_MATRIX_CTRL settings:
		 // 00: Disable
			// 01: Inside DISP_LUT_CONTROL
			// 10: Outside DISP_LUT_CONTROL
		 // 11: All pixels
		 gm_SetRegBitsDWord(GAMMA_LUT2_CTRL, BIT12);
   
		 gm_WriteRegWord (W_Addr + COEF_11, ccMatrix[0]);
		 gm_WriteRegWord (W_Addr + COEF_12, ccMatrix[1]);
		 gm_WriteRegWord (W_Addr + COEF_13, ccMatrix[2]);
		 gm_WriteRegWord (W_Addr + COEF_21, ccMatrix[3]);
		 gm_WriteRegWord (W_Addr + COEF_22, ccMatrix[4]);
		 gm_WriteRegWord (W_Addr + COEF_23, ccMatrix[5]);
		 gm_WriteRegWord (W_Addr + COEF_31, ccMatrix[6]);
		 gm_WriteRegWord (W_Addr + COEF_32, ccMatrix[7]);
		 gm_WriteRegWord (W_Addr + COEF_33, ccMatrix[8]);
   
			// ODP Input offset for xvYCC
			if((stInput[gmvb_MainChannel].Flags & gmd_INPUT_xvYCC_601) ||
			   (stInput[gmvb_MainChannel].Flags & gmd_INPUT_xvYCC_709))    
			{
			   // input offset = -Offset_OUT, -3923 = 0x70AD
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET1, 0x70AD);
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET2, 0x70AD);
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET3, 0x70AD);
   
			//gm_Printf(" ~~~~ xvYCC In Offset ...", 0);
			}
			else
			{
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET1, 0);
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET2, 0);
			   gm_WriteRegWord(GAMMA_LUT_MATRIX_IN_OFFSET3, 0); 		   
   
			//gm_Printf(" ~~~~ No Offset ...", 0);
			}		  
   
		 // Offset
		 {
			gm_WriteRegWord(GAMMA_LUT_MATRIX_OUT_OFFSET1, 0);
			gm_WriteRegWord(GAMMA_LUT_MATRIX_OUT_OFFSET2, 0);
			gm_WriteRegWord(GAMMA_LUT_MATRIX_OUT_OFFSET3, 0);	   
		 }
	  }
					
   if (ptr_GammaDescr != NULL_PTR)
   {
      WORD far * ptr_GammaTable;
	
      // LUT1
      for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
      {
		 WORD W_TableSize = 512;

         ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLut1[B_Count];
         
		 // Update Steep
		 if(B_Count > BLUE_VLUT_COMPONENT)
		 {
		 	W_TableSize = 128;
            ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLUT1Steep[B_Count-3];            
		 }
		 
         if(ptr_GammaTable)
	    		{
            if(((gm_ReadRegWord(GAMMA_LUT1_CTRL)&GAMMA_LUT1_CTL) == 0) && (B_Count < 3))
            {
               gm_SetRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
            }
            gm_LoadImpVlutTable(B_Count, 0, W_TableSize, ptr_GammaTable, 0);
	    		 }
	    		else
	    		{
            //gm_Printf("~~~~ No Gamma LUT1 Table ... %d", B_Count);
         }            
      }

      // Need to add final entry
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_R, 0x4000);
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_G, 0x4000);
      gm_WriteRegWord(GAMMA_LUT1_FINAL_ENTRY_B, 0x4000);

      //gm_Printf("~~~~ B_GammaLUT1_SteepEnable = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepEnable);

      if((*ptr_GammaDescr)->B_GammaLUT1_SteepEnable)
      {
         //gm_Printf("~~~~ SteepStep = %d ...", (*ptr_GammaDescr)->B_GammaLUT1_SteepStep);
         gm_ClearAndSetBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_STEEP_ST, GAMMA_LUT1_STEEP_CT|((*ptr_GammaDescr)->B_GammaLUT1_SteepStep << 12));
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_R, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_R, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[0]);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_G, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_G, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[1]);         
         gm_WriteRegWord(GAMMA_LUT1_STEEP_STRT_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepStart);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_END_B, (*ptr_GammaDescr)->W_GammaLUT1_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT1_STEEP_FINAL_B, (*ptr_GammaDescr)->Wp_GammaLUT1_SteepFinal[2]);         
      }

      // LUT2
      for (B_Count = RED_VLUT_COMPONENT; B_Count <= BLUE_STEEP_VLUT_COMPONENT; B_Count++)
      {
         WORD W_TableSize = 512;         

         ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLut2[B_Count];
					
         // Update Steep
         if (B_Count > BLUE_VLUT_COMPONENT)
         {
            W_TableSize = 128;
            ptr_GammaTable = (WORD far *)(*ptr_GammaDescr)->GammaLUT2Steep[B_Count-3];
         }

         if (ptr_GammaTable)
         {
            if (((gm_ReadRegWord(GAMMA_LUT2_CTRL)&GAMMA_LUT2_CTL) == 0) && (B_Count < 3))
            {
               gm_SetRegBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_CTL);
            }
            gm_LoadVlutTable(B_Count, 0, W_TableSize, ptr_GammaTable, 0);
         }
         else
         {
            //gm_Printf("~~~~ No Gamma LUT2 Table ... %d", B_Count);
         }
      }

      // Need to add final entry
      gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_R, 0x4000);
      gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_G, 0x4000);
      gm_WriteRegWord(GAMMA_LUT2_FINAL_ENTRY_B, 0x4000);

      //gm_Printf("~~~~ B_GammaLUT2_SteepEnable = %d ...", (*ptr_GammaDescr)->B_GammaLUT2_SteepEnable);

      if ((*ptr_GammaDescr)->B_GammaLUT2_SteepEnable)
      {
         //gm_Printf("~~~~ 2 SteepStep = %d ...", (*ptr_GammaDescr)->B_GammaLUT2_SteepStep);
         gm_ClearAndSetBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_STEEP_ST, GAMMA_LUT2_STEEP_CT|((*ptr_GammaDescr)->B_GammaLUT2_SteepStep << 8));
         gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_R, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_END_R, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_R, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[0]);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_G, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_END_G, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_G, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[1]);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_STRT_B, (*ptr_GammaDescr)->W_GammaLUT2_SteepStart);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_END_B, (*ptr_GammaDescr)->W_GammaLUT2_SteepEnd);
         gm_WriteRegWord(GAMMA_LUT2_STEEP_FINAL_B, (*ptr_GammaDescr)->Wp_GammaLUT2_SteepFinal[2]);
      }
   }
   else
   {
      // Disable Gamma LUT Table
      gm_ClearRegBitsWord(GAMMA_LUT1_CTRL, GAMMA_LUT1_CTL);
      gm_ClearRegBitsWord(GAMMA_LUT2_CTRL, GAMMA_LUT2_CTL|GAMMA_LUT2_STEEP_CT);
   }

   //gm_WriteRegWord (DISP_LUT_CONTROL, DISP_LUT_WINDOW_TYPE); // sRGB, Dither, OD need to set the window
   gm_WriteRegWord (DISP_LUT_CONTROL, BIT0|BIT1); // sRGB, Dither, OD need to set the window for main only ...

#if (FEATURE_DITHER == ENABLE)
   #ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()!=CHIPID_4K2K_FE)
   #endif
      Dither_UploadDitherTable(); // Always run dither ...
#endif

   #if (FEATURE_DUM == ENABLE)
	#if defined(SAVING_DATA_INTO_FLASH) || defined(SAVING_DATA_INTO_NVRAM) // Flash data saving 	 
   	// load dum at init.c from flash data
   		//120807 Edward add for load uniformity by preset mode
   		if(IS_UNIFORMITY_GrayOut && IS_UNIFORMITY_ON())//make sure the uniformity is set off
			UserPrefDUMSwitch = UNIFORMITY_OFF;
		
		DisplayUniformityModule(UserPrefDUMSwitch, FALSE, 1, 1, PanelWidth, PanelHeight);
   	#else
   		DisplayUniformityModule(FALSE, FALSE, 1, 1, PanelWidth, PanelHeight);
   	#endif
   #endif

   	#if 1//120928 Edward to avoid garbage
		if(gm_WaitDisplayBlanking_CH(CH_A)) //KevinL 20120923 force update on blanking period immediatelly 
			gm_ForceUpdate(gmvb_MainChannel, OUTPUT_CLOCK);	
		else
			gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);	
	#else
		gm_WaitDisplayBlanking(CH_A);		//Neil120801+ for update in blanking to reduce garbage
		gm_SyncUpdateWait(gmvb_MainChannel, OUTPUT_CLOCK);
	#endif
   
}
#else
void AdjustGammaCorrection_ColorSpace(void)
{}
#endif
void AdjustGammaCorrection_Ext(void)//Added by ChengLin 20130226
{
	//Added by ChengLin 20130226
#ifdef ST_4K2K_93xx_BOARD
	if(GetChipID_4K2K()==CHIPID_4K2K_R)
	{
#if ENABLE_SOC_IPC_BUSY_CHECK
		/*ChengLin 20130124: New 4k2k board BUSY status check*/
		if(!SocIPCIsSlaveLeftReady())
			return;
#endif                                                 
		SocIPCSendCmdPacketParser(SOCIPC_DEVICEL_DST_ADDRESS, SICMD_RW_GAMMA_CORRECTION_CONTRL, NULL);
	}
#endif

	AdjustGammaCorrection();
}
#endif

//******************************************************************************
//
// FUNCTION       : void AdjustImpVlut(void)
//
// USAGE          : Enable IMP Gamma and download proper LUT by command from OSD:
//
// GLOBALS        :  UserPrefImpGammaTable;
//                   gmvb_MainChannel;
//                   gmvs_InputConfigTblPtr
//
// USED_REGS      :
//******************************************************************************

void AdjustImpVlut(void)
{
   // This function is not used anymore...
}


#ifdef ADJUSTER_FACTORYCUSTOMONOFF_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustFactoryCustom(void)
//
// USAGE          : Blank function
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefFactoryCustomOnOff
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustFactoryCustom(void)
{
   //UserPrefFactoryCustomOnOff is already updated by the time this function is called
   gm_Print("UserPrefFactoryCustomOnOff = %d", UserPrefFactoryCustomOnOff);
}
#endif


//******************************************************************************
//
// FUNCTION       : BOOL IsAcmUsed (void)
//
// USAGE          : Determines if ACM is used or not (based on condition of several userpreferences
//
// INPUT          : None
//
// OUTPUT         : TRUE or FALSE
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
BOOL IsAcmUsed (void)
{
#ifdef DELL_U2410F//120208 Edward ACC/ACM depend on OSD setting copy from 2410
   if (UserPrefFleshToneComp || UserPrefBlueStretch || IsAcmEnablePresetMode())	// UserPrefACM3DScheme
#else
   if (UserPrefFleshToneComp || UserPrefBlueStretch || UserPrefImageScheme ) // UserPrefACM3DScheme
#endif
   {
      //SETBIT (gmvw_AccAcmMode, ACM_ON);
      //CLRBIT (gmvw_AccAcmMode, ACM_OFF);
      //gm_Printf("~~~~ IsAcmUsed ACM ON", 0);
      return TRUE;
   }
   else
   {
      //CLRBIT (gmvw_AccAcmMode, ACM_ON);
      //SETBIT (gmvw_AccAcmMode, ACM_OFF);
      //gm_Printf("~~~~ IsAcmUsed ACM OFF", 0);
      return FALSE;
   }
}

#if 0
//******************************************************************************
//
// FUNCTION       : BYTE GetMaxAcmTable (void)
//
// USAGE          : Retreive Max ACM table
//
// INPUT          : None
//
// OUTPUT         : Max ACM table
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
BYTE GetMaxAcmTable (void)
{
   BYTE B_MaxTable = gm_GetNumAcmTable();
   msg_i ("Max ACM table is = %d", B_MaxTable);
   return (B_MaxTable);
}
#endif

#ifdef Action_AdjustAcmYellowSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmYellowSat(void)
//
// USAGE      :   Adjust ACM Yellow Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmYellowSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                              
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_YELLOW );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(YELLOW_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(YELLOW_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmCyanSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmCyanSat(void)
//
// USAGE      :   Adjust ACM Cyan Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmCyanSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                 
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_CYAN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(CYAN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(CYAN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmGreenSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmGreenSat(void)
//
// USAGE      :   Adjust ACM Green Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmGreenSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                    
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_GREEN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(GREEN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(GREEN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmMagentaSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmMagentaSat(void)
//
// USAGE      :   Adjust ACM Magenta Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmMagentaSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif    
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_MAGENTA );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(MAGENTA_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(MAGENTA_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmRedSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmRedSat(void)
//
// USAGE      :   Adjust ACM Red Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmRedSat(void)
{

//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif       
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_RED );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(RED_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(RED_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmBlueSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueSat(void)
//
// USAGE      :   Adjust ACM Blue Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlueSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif          
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_BLUE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(BLUE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLUE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmBlackSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueSat(void)
//
// USAGE      :   Adjust ACM Blue Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlackSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif             
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_BLACK );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(BLACK_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLACK_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmWhiteSat_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueSat(void)
//
// USAGE      :   Adjust ACM Blue Saturation
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmWhiteSat(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                
      SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_SAT_WHITE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(WHITE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(WHITE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmYellowHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmYellowHue(void)
//
// USAGE      :   Adjust ACM Yellow Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmYellowHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	 /*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                   
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_YELLOW );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(YELLOW_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(YELLOW_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmCyanHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmCyanHue(void)
//
// USAGE      :   Adjust ACM Cyan Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmCyanHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                      
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_CYAN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(CYAN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(CYAN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmBlackHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmYellowHue(void)
//
// USAGE      :   Adjust ACM Yellow Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlackHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                      
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_BLACK );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(BLACK_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLACK_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmWhiteHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmYellowHue(void)
//
// USAGE      :   Adjust ACM Yellow Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmWhiteHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                      
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_WHITE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(WHITE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(WHITE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmGreenHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmGreenHue(void)
//
// USAGE      :   Adjust ACM Green Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmGreenHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                         
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_GREEN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(GREEN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(GREEN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmMagentaHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmMagentaHue(void)
//
// USAGE      :   Adjust ACM Magenta Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmMagentaHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                            
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_MAGENTA );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(MAGENTA_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(MAGENTA_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmRedHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmRedHue(void)
//
// USAGE      :   Adjust ACM Red Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmRedHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                               
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_RED );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(RED_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(RED_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmBlueHue_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueHue(void)
//
// USAGE      :   Adjust ACM Blue Hue
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlueHue(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                  
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_HUE_BLUE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(BLUE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLUE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmYellowLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmYellowLuma(void)
//
// USAGE      :   Adjust ACM Yellow Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmYellowLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                     
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_YELLOW );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(YELLOW_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(YELLOW_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmCyanLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmCyanLuma(void)
//
// USAGE      :   Adjust ACM Cyan Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmCyanLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                        
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_CYAN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(CYAN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(CYAN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmGreenLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmGreenLuma(void)
//
// USAGE      :   Adjust ACM Green Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmGreenLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                           
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_GREEN );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(GREEN_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(GREEN_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmMagentaLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmMagentaLuma(void)
//
// USAGE      :   Adjust ACM Magenta Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmMagentaLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                              
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_MAGENTA );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(MAGENTA_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(MAGENTA_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmRedLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmRedLuma(void)
//
// USAGE      :   Adjust ACM Red Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmRedLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                                 
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_RED );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(RED_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(RED_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif


#ifdef Action_AdjustAcmBlueLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueLuma(void)
//
// USAGE      :   Adjust ACM Blue Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlueLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                                 
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_BLUE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   AdjustSixAxisColor(BLUE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLUE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmBlackLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueLuma(void)
//
// USAGE      :   Adjust ACM Blue Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmBlackLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                                    
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_BLACK );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(BLACK_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(BLACK_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#ifdef Action_AdjustAcmWhiteLuma_WB_Used
//******************************************************************************
// FUNCTION      :   void AdjustAcmBlueLuma(void)
//
// USAGE      :   Adjust ACM Blue Luma
//
// INPUT      :   None
//
// OUTPUT      :   None
//
// GLOBALS      :   None
//
// USED_REGS   :   None
//
// PRE_CONDITION   :
//
// POST_CONDITION   :
//******************************************************************************
void AdjustAcmWhiteLuma(void)
{
//Added by ChengLin 20130110
#ifdef ST_4K2K_93xx_BOARD
   if(GetChipID_4K2K()==CHIPID_4K2K_R)
   {
#if ENABLE_SOC_IPC_BUSY_CHECK
	/*ChengLin 20130124: New 4k2k board BUSY status check*/
	if(!SocIPCIsSlaveLeftReady())
		return;
#endif                                                       
   	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_SIX_AXIS_BRI_WHITE );
   }
#endif

   #if (FEATURE_COLORWARP == REV1)
   //AdjustSixAxisColor(WHITE_AXIS);
   #else // (FEATURE_COLORWARP == REV2)
   AdjustColorWarp(WHITE_AXIS);
   #endif // (FEATURE_COLORWARP == REV1)
}
#endif

#if 0 // def Action_AdjustColorScheme_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustColorScheme(void)
//
// USAGE          : Adjust Color Scheme
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefColorScheme      (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustColorScheme(void)
{
   if (UserPrefColorScheme < NUM_COLOR_SCHEMES)
      gm_UpdateColorScheme(UserPrefColorScheme);
}
#endif

#if (FEATURE_ACM_3D == ENABLE)
//******************************************************************************
//
// FUNCTION       : void AdjustACM3DColorScheme(void)
//
// USAGE          : Adjust ACM3D Color Scheme
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefImageScheme      (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustACM3DColorScheme(void)
{
   BYTE B_CurrRegion;
//gm_Print("########UserPrefColorMode  %d",UserPrefColorMode);
//gm_Print("########UserPrefGraphicsImageMode  %d",UserPrefGraphicsImageMode);
//gm_Print("########UserPrefVideoImageMode  %d",UserPrefVideoImageMode);


#ifdef DELL_U2410F
	if(UserPrefColorMode == ColorMode_GRAPHIC)
		{
			switch(UserPrefGraphicsImageMode)
			{
				case Graphics_MULTIMEDIA:
					ACM3DSetColorScheme(MULTIMEDIA_ACM3D_SCHEME);		   
					break;
					
				case Graphics_GAME:
					ACM3DSetColorScheme(GAME_ACM3D_SCHEME);		   
					break;
					
				case Graphics_MOVIE:	//Neil 20120522+
					ACM3DSetColorScheme(MOVIE_ACM3D_SCHEME);
					break;

					
				case Graphics_COLOR_SPACE:
					if(UserPrefPresetColorSpace == CSPACE_AdobeRGB)
						ACM3DSetColorScheme(ADOBE_YUV_ACM3D_SCHEME);		   
					else if(UserPrefPresetColorSpace == CSPACE_sRGB)
						ACM3DSetColorScheme(SRGB_YUV_ACM3D_SCHEME);		
					break;		

				case Graphics_TEXT:		//Neil 20120522+
				case Graphics_CUSTOM_COLOR:
					ACM3DSetColorScheme(CUSTOM_ACM3D_SCHEME);
					break;
					
				case Graphics_STANDARD:		//Neil 20120522+
				default:
					ACM3DSetColorScheme(OFF_ACM3D_SCHEME); //??
					break;
			}
		}
		else  //ColorMode_VIDEO
		{
			switch(UserPrefVideoImageMode)
			{
				case Video_MOVIE:
					ACM3DSetColorScheme(MOVIE_ACM3D_SCHEME);		   
					break;

				case Video_GAME:
					ACM3DSetColorScheme(GAME_ACM3D_SCHEME);		   
					break;
					
				case Video_NATURE:
					ACM3DSetColorScheme(NATURE_ACM3D_SCHEME);		   
					break;
						
				case Video_xvMode:
					ACM3DSetColorScheme(XVYCC_ACM3D_SCHEME);		   
					break;
					
				default:					
					ACM3DSetColorScheme(OFF_ACM3D_SCHEME); //??
					break;
			}
		}

		gm_ACM3DInit();

		#ifdef USE_6AXIS
		//Program User Defined Correction Parameters (6axis control)
		// for every Zone from REGION_MAGENTA to REGION_BLUE
		#if 0 //zuguang test
		#ifdef DELL_U2410F	// Modified by ST_hansPENG 081007
		if ((IsAcmEnablePresetMode()) && !IsPresetMode_VIDEO_xvMode)	// KevinL 20090206 XvYcc do not adjust user 6-axis color
		#else
		if (UserPrefImageScheme == CUSTOM_ACM3D_SCHEME)
		#endif
		#endif	//zuguang test

		if(UserPrefColorMode == ColorMode_GRAPHIC) //KevinL 20090417
		{
			if (UserPrefGraphicsImageMode == Graphics_CUSTOM_COLOR)	//zuguang 20090220
			{
				for (B_CurrRegion = 0; B_CurrRegion < 6; B_CurrRegion++)
				{
					AdjustSixAxisColor(B_CurrRegion);
				}
				gm_SyncUpdate(CH_A, OUTPUT_CLOCK);
			}
		}
		#endif

		// to inform Library about ACM status
		gm_UpdateACM3DColorScheme(IsAcmEnablePresetMode());
		
#else   

   #if (FEATURE_VWD==ENABLE)
   if ((IsVWDEnabled() == FALSE) && (UserPrefImageScheme < NUM_IMAGE_SCHEMES))
#else
   if (UserPrefImageScheme < NUM_IMAGE_SCHEMES)
#endif
   {
      // Select proper ACMD tables and load them
      ACM3DSetColorScheme(UserPrefImageScheme);
      gm_ACM3DInit();

      // to inform Library about ACM status
      gm_UpdateACM3DColorScheme(UserPrefImageScheme);
   }
   
#endif

}
#endif

#ifdef Action_AdjustTTXLanguageGroup_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustTTXLanguageGroup(void)
//
// USAGE          : Adjust the language group used in the TTX decoder
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefTTXLanguageGroup      (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustTTXLanguageGroup(void)
{
}
#endif

#ifdef Action_AdjustAVSDelayOnOff_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustAVSDelayOnOff(void)
//
// USAGE          : Used to tun ON/OFF AVS Delay
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefAVSDelay    (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustAVSDelayOnOff(void)
{
#if (FEATURE_AUDIO == ENABLE)
   SYS_API_AUDIO_AVS_SetDelayOnOff(UserPrefAVSDelay);
#endif
}
#endif

#ifdef Action_AdjustAVSDelayTime_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustAVSDelayTime(void)
//
// USAGE          : Used to adjust AVS Delay time
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : UserPrefAVSDelayTime    (R)
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustAVSDelayTime(void)
{
   if (UserPrefAVSDelayTime == 0)
   {
      UserPrefAVSDelay = 0;
      //return;
   }

#if (FEATURE_AUDIO == ENABLE)
   gm_AUDIO_Adjuster();
#endif
}
#endif

#ifdef ADJUSTER_BLUESTRETCH_DECLARED
//******************************************************************************
//
// FUNCTION       : void AdjustBlueStretch(void)
//
// USAGE          : Turn Blue Stretch to Off/Low/Med/High.  This feature is for Cortez Advanced only.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  :
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustBlueStretch(void)
{
#if (FEATURE_VIDEO_BLUESTRETCH == ENABLE)
   gmt_BlueStretchStruct BlueStretchStruct;

   switch (UserPrefBlueStretch)
   {
      case BLUE_STRETCH_LOW:
         BlueStretchStruct.B_Gain = 0x2;
         break;

      case BLUE_STRETCH_MED:
         BlueStretchStruct.B_Gain = 0x4;
         break;

      case BLUE_STRETCH_HIGH:
         BlueStretchStruct.B_Gain = 0x6;
         break;

      case BLUE_STRETCH_OFF:
      default:
         BlueStretchStruct.B_Gain = 0x0;
   }

   BlueStretchStruct.B_Area = 0x14;   //recommended value
   BlueStretchStruct.Region = gmd_BLUE_STRETCH_FULL_SCREEN;
   BlueStretchStruct.Y_OPT_EN = TRUE;
   BlueStretchStruct.G_OPT_EN = TRUE;
   BlueStretchStruct.SAT_LIM_EN = TRUE;
   BlueStretchStruct.G_OPTION = 0x3F4;
   BlueStretchStruct.LUMA_MIN = 0x2F0;
   BlueStretchStruct.SAT_LIM = 0x50;

   gm_DisplayBlueStretchSetup(&BlueStretchStruct);

   if (UserPrefBlueStretch == BLUE_STRETCH_OFF)
   {
      gm_VideoProcessingDisable(VIDEO_BLUESTRETCH);
   }
   else
   {
      gm_VideoProcessingEnable(VIDEO_BLUESTRETCH);
   }
//#elif (FEATURE_ACM_3D == ENABLE)
//   AdjustACM3DColorScheme();
#endif
}
#endif

//******************************************************************************
//   Engineering Menu - last Tab in Factory Menu
//******************************************************************************

//------------------------------- MVF (START) ----------------------------------
#ifdef Action_AdjustMVF_SHARPNESS_LUMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_SHARPNESS_LUMA(void)
//
// USAGE          : Write UserPref to MVF_SHARPNESS_LUMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_SHARPNESS_LUMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_SHARPNESS_LUMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_SHARPNESS);
   W_Reg = (W_Reg & ~MVF_SHARPNESS_LUMA) + (MVF_SHARPNESS_LUMA & UserPrefReg_MVF_SHARPNESS_LUMA);
   gm_WriteRegWord( MVF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMVF_SHARPNESS_CHROMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_SHARPNESS_CHROMA(void)
//
// USAGE          : Write UserPref to MVF_SHARPNESS_CHROMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_SHARPNESS_CHROMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_SHARPNESS_CHROMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_SHARPNESS);
   W_Reg = (W_Reg & ~MVF_SHARPNESS_CHROMA) + (UserPrefReg_MVF_SHARPNESS_CHROMA << 8);
   gm_WriteRegWord( MVF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMVF_NOISE_CORING_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_NOISE_CORING_THRESH(void)
//
// USAGE          : Write UserPref to MVF_NOISE_CORING_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_NOISE_CORING_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_NOISE_CORING_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
#if (FEATURE_NOISE_CORING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(MVF_NOISE_CORING_CTRL);
   W_Reg = (W_Reg & ~MVF_NOISE_CORING_THRESH) + (MVF_NOISE_CORING_THRESH & UserPrefReg_MVF_NOISE_CORING_THRESH);
   gm_WriteRegWord( MVF_NOISE_CORING_CTRL, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
#endif
}
#endif

#ifdef Action_AdjustMVF_NONLINEAR_THRESH1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_NONLINEAR_THRESH1(void)
//
// USAGE          : Write UserPref to MVF_NONLINEAR_THRESH1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_NONLINEAR_THRESH1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_NONLINEAR_CTRL1);
   WORD W_Thr = MVF_NONLINEAR_THRESH1 & (UserPrefReg_MVF_NONLINEAR_THRESH1 << 3); // mapping Slider
   W_Reg = (W_Reg & ~MVF_NONLINEAR_THRESH1) + W_Thr;
   gm_WriteRegWord( MVF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMVF_NONLINEAR_GAIN1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_NONLINEAR_GAIN1(void)
//
// USAGE          : Write UserPref to MVF_NONLINEAR_GAIN1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_NONLINEAR_GAIN1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_NONLINEAR_CTRL1);
   W_Reg = (W_Reg & ~MVF_NONLINEAR_GAIN1) +
           (MVF_NONLINEAR_GAIN1 & (UserPrefReg_MVF_NONLINEAR_GAIN1 << 11)); // mapping Slider
   gm_WriteRegWord( MVF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMVF_NONLINEAR_THRESH2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_NONLINEAR_THRESH2(void)
//
// USAGE          : Write UserPref to MVF_NONLINEAR_THRESH2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_NONLINEAR_THRESH2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_NONLINEAR_CTRL2);
   WORD W_Thr = MVF_NONLINEAR_THRESH2 & (UserPrefReg_MVF_NONLINEAR_THRESH2 << 3); // mapping Slider
   W_Reg = (W_Reg & ~MVF_NONLINEAR_THRESH2) + W_Thr;
   gm_WriteRegWord( MVF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMVF_NONLINEAR_GAIN2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMVF_NONLINEAR_GAIN2(void)
//
// USAGE          : Write UserPref to MVF_NONLINEAR_GAIN2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMVF_NONLINEAR_GAIN2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_NONLINEAR_CTRL2);
   W_Reg = (W_Reg & ~MVF_NONLINEAR_GAIN2) +
           (MVF_NONLINEAR_GAIN2 & (UserPrefReg_MVF_NONLINEAR_GAIN2 << 11)); // mapping Slider
   gm_WriteRegWord( MVF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif
//------------------------------- MVF (END) ------------------------------------


//------------------------------- MHF (START) ----------------------------------
#ifdef Action_AdjustMHF_SHARPNESS_LUMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_SHARPNESS_LUMA(void)
//
// USAGE          : Write UserPref to MHF_SHARPNESS_LUMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_SHARPNESS_LUMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_SHARPNESS_LUMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_SHARPNESS);
   W_Reg = (W_Reg & ~MHF_SHARPNESS_LUMA) + (MHF_SHARPNESS_LUMA & UserPrefReg_MHF_SHARPNESS_LUMA);
   gm_WriteRegWord( MHF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMHF_SHARPNESS_CHROMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_SHARPNESS_CHROMA(void)
//
// USAGE          : Write UserPref to MHF_SHARPNESS_CHROMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_SHARPNESS_CHROMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_SHARPNESS_CHROMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_SHARPNESS);
   W_Reg = (W_Reg & ~MHF_SHARPNESS_CHROMA) + (UserPrefReg_MHF_SHARPNESS_CHROMA << 8);
   gm_WriteRegWord( MHF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMHF_NOISE_CORING_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_NOISE_CORING_THRESH(void)
//
// USAGE          : Write UserPref to MHF_NOISE_CORING_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_NOISE_CORING_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_NOISE_CORING_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
#if (FEATURE_NOISE_CORING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(MHF_NOISE_CORING_CTRL);
   W_Reg = (W_Reg & ~MHF_NOISE_CORING_THRESH) + (MHF_NOISE_CORING_THRESH & UserPrefReg_MHF_NOISE_CORING_THRESH);
   gm_WriteRegWord( MHF_NOISE_CORING_CTRL, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
#endif
}
#endif

#ifdef Action_AdjustMHF_NONLINEAR_THRESH1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_NONLINEAR_THRESH1(void)
//
// USAGE          : Write UserPref to MHF_NONLINEAR_THRESH1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_NONLINEAR_THRESH1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_NONLINEAR_CTRL1);
   WORD W_Thr = MHF_NONLINEAR_THRESH1 & (UserPrefReg_MHF_NONLINEAR_THRESH1 << 3); // mapping Slider
   W_Reg = (W_Reg & ~MHF_NONLINEAR_THRESH1) + W_Thr;
   gm_WriteRegWord( MHF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMHF_NONLINEAR_GAIN1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_NONLINEAR_GAIN1(void)
//
// USAGE          : Write UserPref to MHF_NONLINEAR_GAIN1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_NONLINEAR_GAIN1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_NONLINEAR_CTRL1);
   W_Reg = (W_Reg & ~MHF_NONLINEAR_GAIN1) +
           (MHF_NONLINEAR_GAIN1 & (UserPrefReg_MHF_NONLINEAR_GAIN1 << 11)); // mapping Slider
   gm_WriteRegWord( MHF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMHF_NONLINEAR_THRESH2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_NONLINEAR_THRESH2(void)
//
// USAGE          : Write UserPref to MHF_NONLINEAR_THRESH2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_NONLINEAR_THRESH2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_NONLINEAR_CTRL2);
   WORD W_Thr = MHF_NONLINEAR_THRESH2 & (UserPrefReg_MHF_NONLINEAR_THRESH2 << 3); // mapping Slider
   W_Reg = (W_Reg & ~MHF_NONLINEAR_THRESH2) + W_Thr;
   gm_WriteRegWord( MHF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustMHF_NONLINEAR_GAIN2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMHF_NONLINEAR_GAIN2(void)
//
// USAGE          : Write UserPref to MHF_NONLINEAR_GAIN2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMHF_NONLINEAR_GAIN2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_NONLINEAR_CTRL2);
   W_Reg = (W_Reg & ~MHF_NONLINEAR_GAIN2) +
           (MHF_NONLINEAR_GAIN2 & (UserPrefReg_MHF_NONLINEAR_GAIN2 << 11)); // mapping Slider
   gm_WriteRegWord( MHF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif
//------------------------------- MHF (END) ------------------------------------


//------------------------------- PVF (START) ----------------------------------
#ifdef Action_AdjustPVF_SHARPNESS_LUMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_SHARPNESS_LUMA(void)
//
// USAGE          : Write UserPref to PVF_SHARPNESS_LUMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_SHARPNESS_LUMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_SHARPNESS_LUMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_SHARPNESS);
   W_Reg = (W_Reg & ~PVF_SHARPNESS_LUMA) + (PVF_SHARPNESS_LUMA & UserPrefReg_PVF_SHARPNESS_LUMA);
   gm_WriteRegWord( PVF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPVF_SHARPNESS_CHROMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_SHARPNESS_CHROMA(void)
//
// USAGE          : Write UserPref to PVF_SHARPNESS_CHROMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_SHARPNESS_CHROMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_SHARPNESS_CHROMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_SHARPNESS);
   W_Reg = (W_Reg & ~PVF_SHARPNESS_CHROMA) + (UserPrefReg_PVF_SHARPNESS_CHROMA << 8);
   gm_WriteRegWord( PVF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPVF_NOISE_CORING_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_NOISE_CORING_THRESH(void)
//
// USAGE          : Write UserPref to PVF_NOISE_CORING_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_NOISE_CORING_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_NOISE_CORING_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
#if (FEATURE_NOISE_CORING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(PVF_NOISE_CORING_CTRL);
   W_Reg = (W_Reg & ~PVF_NOISE_CORING_THRESH) + (PVF_NOISE_CORING_THRESH & UserPrefReg_PVF_NOISE_CORING_THRESH);
   gm_WriteRegWord( PVF_NOISE_CORING_CTRL, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
#endif
}
#endif

#ifdef Action_AdjustPVF_NONLINEAR_THRESH1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_NONLINEAR_THRESH1(void)
//
// USAGE          : Write UserPref to PVF_NONLINEAR_THRESH1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_NONLINEAR_THRESH1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_NONLINEAR_CTRL1);
   WORD W_Thr = PVF_NONLINEAR_THRESH1 & (UserPrefReg_PVF_NONLINEAR_THRESH1 << 3); // mapping Slider
   W_Reg = (W_Reg & ~PVF_NONLINEAR_THRESH1) + W_Thr;
   gm_WriteRegWord( PVF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPVF_NONLINEAR_GAIN1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_NONLINEAR_GAIN1(void)
//
// USAGE          : Write UserPref to PVF_NONLINEAR_GAIN1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_NONLINEAR_GAIN1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_NONLINEAR_CTRL1);
   W_Reg = (W_Reg & ~PVF_NONLINEAR_GAIN1) +
           (PVF_NONLINEAR_GAIN1 & (UserPrefReg_PVF_NONLINEAR_GAIN1 << 11)); // mapping Slider
   gm_WriteRegWord( PVF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPVF_NONLINEAR_THRESH2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_NONLINEAR_THRESH2(void)
//
// USAGE          : Write UserPref to PVF_NONLINEAR_THRESH2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_NONLINEAR_THRESH2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_NONLINEAR_CTRL2);
   WORD W_Thr = PVF_NONLINEAR_THRESH2 & (UserPrefReg_PVF_NONLINEAR_THRESH2 << 3); // mapping Slider
   W_Reg = (W_Reg & ~PVF_NONLINEAR_THRESH2) + W_Thr;
   gm_WriteRegWord( PVF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPVF_NONLINEAR_GAIN2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPVF_NONLINEAR_GAIN2(void)
//
// USAGE          : Write UserPref to PVF_NONLINEAR_GAIN2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PVF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPVF_NONLINEAR_GAIN2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PVF_NONLINEAR_CTRL2);
   W_Reg = (W_Reg & ~PVF_NONLINEAR_GAIN2) +
           (PVF_NONLINEAR_GAIN2 & (UserPrefReg_PVF_NONLINEAR_GAIN2 << 11)); // mapping Slider
   gm_WriteRegWord( PVF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif
//------------------------------- PVF (END) ------------------------------------


//------------------------------- PHF (START) ----------------------------------
#ifdef Action_AdjustPHF_SHARPNESS_LUMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_SHARPNESS_LUMA(void)
//
// USAGE          : Write UserPref to PHF_SHARPNESS_LUMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_SHARPNESS_LUMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_SHARPNESS_LUMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_SHARPNESS);
   W_Reg = (W_Reg & ~PHF_SHARPNESS_LUMA) + (PHF_SHARPNESS_LUMA & UserPrefReg_PHF_SHARPNESS_LUMA);
   gm_WriteRegWord( PHF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPHF_SHARPNESS_CHROMA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_SHARPNESS_CHROMA(void)
//
// USAGE          : Write UserPref to PHF_SHARPNESS_CHROMA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_SHARPNESS_CHROMA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_SHARPNESS_CHROMA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_SHARPNESS);
   W_Reg = (W_Reg & ~PHF_SHARPNESS_CHROMA) + (UserPrefReg_PHF_SHARPNESS_CHROMA << 8);
   gm_WriteRegWord( PHF_SHARPNESS, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPHF_NOISE_CORING_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_NOISE_CORING_THRESH(void)
//
// USAGE          : Write UserPref to PHF_NOISE_CORING_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_NOISE_CORING_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_NOISE_CORING_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
#if (FEATURE_NOISE_CORING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(PHF_NOISE_CORING_CTRL);
   W_Reg = (W_Reg & ~PHF_NOISE_CORING_THRESH) + (PHF_NOISE_CORING_THRESH & UserPrefReg_PHF_NOISE_CORING_THRESH);
   gm_WriteRegWord( PHF_NOISE_CORING_CTRL, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
#endif
}
#endif

#ifdef Action_AdjustPHF_NONLINEAR_THRESH1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_NONLINEAR_THRESH1(void)
//
// USAGE          : Write UserPref to PHF_NONLINEAR_THRESH1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_NONLINEAR_THRESH1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_NONLINEAR_CTRL1);
   WORD W_Thr = PHF_NONLINEAR_THRESH1 & (UserPrefReg_PHF_NONLINEAR_THRESH1 << 3); // mapping Slider
   W_Reg = (W_Reg & ~PHF_NONLINEAR_THRESH1) + W_Thr;
   gm_WriteRegWord( PHF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPHF_NONLINEAR_GAIN1_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_NONLINEAR_GAIN1(void)
//
// USAGE          : Write UserPref to PHF_NONLINEAR_GAIN1
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_NONLINEAR_CTRL1
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_NONLINEAR_GAIN1(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_NONLINEAR_CTRL1);
   W_Reg = (W_Reg & ~PHF_NONLINEAR_GAIN1) +
           (PHF_NONLINEAR_GAIN1 & (UserPrefReg_PHF_NONLINEAR_GAIN1 << 11)); // mapping Slider
   gm_WriteRegWord( PHF_NONLINEAR_CTRL1, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPHF_NONLINEAR_THRESH2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_NONLINEAR_THRESH2(void)
//
// USAGE          : Write UserPref to PHF_NONLINEAR_THRESH2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_NONLINEAR_THRESH2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_NONLINEAR_CTRL2);
   WORD W_Thr = PHF_NONLINEAR_THRESH2 & (UserPrefReg_PHF_NONLINEAR_THRESH2 << 3); // mapping Slider
   W_Reg = (W_Reg & ~PHF_NONLINEAR_THRESH2) + W_Thr;
   gm_WriteRegWord( PHF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustPHF_NONLINEAR_GAIN2_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustPHF_NONLINEAR_GAIN2(void)
//
// USAGE          : Write UserPref to PHF_NONLINEAR_GAIN2
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : PHF_NONLINEAR_CTRL2
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustPHF_NONLINEAR_GAIN2(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(PHF_NONLINEAR_CTRL2);
   W_Reg = (W_Reg & ~PHF_NONLINEAR_GAIN2) +
           (PHF_NONLINEAR_GAIN2 & (UserPrefReg_PHF_NONLINEAR_GAIN2 << 11)); // mapping Slider
   gm_WriteRegWord( PHF_NONLINEAR_CTRL2, W_Reg );
   gm_SyncUpdate(CH_B, INPUT_OUTPUT_CLOCK);
#endif
}
#endif
//------------------------------- PHF (END) ------------------------------------


//------------------------------- Enhancer (START) -----------------------------
#ifdef Action_AdjustHEM_HLE_THR_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_HLE_THR(void)
//
// USAGE          : Write UserPref to HEM_HLE_THR
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_HLE_THR
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_HLE_THR(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif

#ifdef Action_AdjustHEM_HLE_GAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_HLE_GAIN(void)
//
// USAGE          : Write UserPref to HEM_HLE_GAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_HLE_GAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_HLE_GAIN(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif

#ifdef Action_AdjustHEM_HDP_THR_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_HDP_THR(void)
//
// USAGE          : Write UserPref to HEM_HDP_THR
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_HDP_THR
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_HDP_THR(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif

#ifdef Action_AdjustHEM_HDP_GAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_HDP_GAIN(void)
//
// USAGE          : Write UserPref to HEM_HDP_GAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_HDP_GAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_HDP_GAIN(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif

#ifdef Action_AdjustHEM_CE_THR_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_CE_THR(void)
//
// USAGE          : Write UserPref to HEM_CE_THR
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_CE_THR
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_CE_THR(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif

#ifdef Action_AdjustHEM_CE_GAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustHEM_CE_GAIN(void)
//
// USAGE          : Write UserPref to HEM_CE_GAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : HEM_CE_GAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustHEM_CE_GAIN(void)
{
#if (CHIP_ID == STDP93xx)
   // Louis ... To Do --> Check function later
#endif
}
#endif
//------------------------------- Enhancer (END) -------------------------------


#ifdef Action_AdjustVDP_THRESHOLD_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustVDP_THRESHOLD(void)
//
// USAGE          : Write UserPref to VDP_CTRL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : VDP_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustVDP_THRESHOLD(void)
{
#if 0//(FEATURE_VERTICAL_DETAIL_PROCESSING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(VDP_CTRL);
   WORD W_Thr = VDP_THRESHOLD & (UserPrefReg_VDP_THRESHOLD << 4); // mapping Slider
   W_Reg = (W_Reg & ~VDP_THRESHOLD) + W_Thr;
   gm_WriteRegWord( VDP_CTRL, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif

#ifdef Action_AdjustVDP_GAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustVDP_GAIN(void)
//
// USAGE          : Write UserPref to VDP_CTRL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : VDP_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustVDP_GAIN(void)
{
#if 0//(FEATURE_VERTICAL_DETAIL_PROCESSING == ENABLE)
   WORD W_Reg = gm_ReadRegWord(VDP_CTRL);
   WORD W_Thr = VDP_GAIN & UserPrefReg_VDP_GAIN;
   W_Reg = (W_Reg & ~VDP_GAIN) + W_Thr;
   gm_WriteRegWord( VDP_CTRL, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif


#ifdef Action_AdjustMPEGNRMode_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMPEGNRMode(void)
//
// USAGE          : Adjust MPEG NR
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMPEGNRMode(void)
{
#ifdef ST_4K2K_93xx_BOARD
      if(GetChipID_4K2K()==CHIPID_4K2K_R)
      {
#if ENABLE_SOC_IPC_BUSY_CHECK
		/*ChengLin 20130124: New 4k2k board BUSY status check*/
		if(!SocIPCIsSlaveLeftReady())
			return;
#endif                                                             
      	SOCIPC_SyncOSDAdjustHandler( SI_OSD_SYNC_NOISE_REDUCTION );
      }
#endif
	//Hyb130429+ ;
	UserPrefMPEGNR = UserPrefPortMPEGNRMode;
   //if (UserPrefMPEGNRMode == MPEG_NR_OFF)
	if ((UserPrefMPEGNRMode == MPEG_NR_OFF) || (stInput[CH_A].Hactive > 1920) || (stInput[CH_A].Vactive > 1080))
   {
      UserPrefMPEGNRMode = MPEG_NR_OFF;
      gm_VideoProcessingDisable(VIDEO_MNR | VIDEO_GNR);
   }
   else if ( gm_UpdateMpegNrThreshold(UserPrefMPEGNRThresh0,
                                      UserPrefMPEGNRThresh1,
                                      UserPrefMPEGNRThresh2) == OK )
   {
      if (UserPrefMPEGNRMode == MPEG_NR_MOSQ_GAUSS)
      {
         gm_VideoProcessingEnable(VIDEO_MNR | VIDEO_GNR);
      }
      else if (UserPrefMPEGNRMode == MPEG_NR_MOSQ)
      {
         gm_VideoProcessingEnable(VIDEO_MNR);
         gm_VideoProcessingDisable(VIDEO_GNR);
      }
      else
      {
         gm_VideoProcessingEnable(VIDEO_GNR);
         gm_VideoProcessingDisable(VIDEO_MNR);
      }
   }

   gm_SyncUpdate(CH_A, OUTPUT_CLOCK);
}
#endif

#ifdef Action_AdjustMPEGNRThresh_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustMPEGNRThresh(void)
//
// USAGE          : Adjust MPEG NR Thresholds
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustMPEGNRThresh(void)
{
   gm_UpdateMpegNrThreshold(UserPrefMPEGNRThresh0,
                            UserPrefMPEGNRThresh1,
                            UserPrefMPEGNRThresh2);
   gm_SyncUpdate(CH_A, OUTPUT_CLOCK);
}
#endif

#ifdef Action_AdjustACCScheme_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustACCScheme(void)
//
// USAGE          : Adjust the ACC scheme by loading the corresponding table. If
//                  ACC is set to the same scheme as ACM, then
//                  UserPrefImageScheme will be set to the ACC scheme. Otherwise,
//                  UserPrefImageScheme is set to ACC_ACM_SCHEME_OFF.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION : 
//
//******************************************************************************
void AdjustACCScheme(void)
{
#if (FEATURE_ACC3 == ENABLE)
 #if(!defined(ACC_LUT_METHOD))
   if (UserPrefImageScheme < NUM_IMAGE_SCHEMES)//minus one since CUSTOM table is not defined yet
   {
      gm_UpdateAcc(UserPrefImageScheme);
   }
 #endif
#endif
}
#endif


#ifdef DELL_U2410F//120209 Edward add from 2410
//******************************************************************************
//
// FUNCTION       : void AdjustDELLACCScheme(void)
//
// USAGE          : Adjust the ACC scheme by loading the corresponding table. If
//                  ACC is set to the same scheme as ACM, then
//                  UserPrefImageScheme will be set to the ACC scheme. Otherwise,
//                  UserPrefImageScheme is set to ACC_ACM_SCHEME_OFF.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION : 
//
//******************************************************************************
void AdjustDELLACCScheme(void)
{
#if (FEATURE_ACC3 == ENABLE)
	#if (!defined(ACC_LUT_METHOD))
	 	if ((IsAccEnablePresetMode()) &&(gm_IsValidSignal(gmvb_MainChannel))) //120717 Edward update
	 	{
	 		gm_UpdateAcc_DELL(UserPrefGraphicsImageMode);
		 /*if (UserPrefColorMode == ColorMode_GRAPHIC)
			 gm_UpdateAcc_Graphic(UserPrefGraphicsImageMode);
		 else
			 gm_UpdateAcc_Video(UserPrefVideoImageMode);*/
	 	}
	 	else //KevinL 20090304
	 	{
		 	CLRBIT (gmvw_AccAcmMode, ACC_ON);
		 	SETBIT (gmvw_AccAcmMode, ACC_OFF);
		 	gm_VideoProcessingDisable (VIDEO_ACC); 	 
	 	}
	#endif 
#endif
}
#endif

#if 0 // def Action_AdjustACMScheme_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustACMScheme(void)
//
// USAGE          : Adjust the ACM scheme by loading the corresponding table. If
//                  ACM is set to the same scheme as ACC, then
//                  UserPrefImageScheme will be set to the ACM scheme. Otherwise,
//                  UserPrefImageScheme is set to ACC_ACM_SCHEME_OFF.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustACMScheme(void)
{
   if (UserPrefImageScheme < NUM_IMAGE_SCHEMES)//minus one since CUSTOM table is not defined yet
   {
      gm_UpdateColorScheme(UserPrefImageScheme);
   }
}
#endif

#if 0 // def Action_AdjustACCACMScheme_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustACCACMScheme(void)
//
// USAGE          : Adjust both ACC and ACM schemes. Overrides UserPrefACCScheme and
//                  UserPrefImageScheme.
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustACCACMScheme(void)         // PSD
{
   if (UserPrefImageScheme < NUM_IMAGE_SCHEMES)//CUSTOM is not available
   {
#if(!defined(ACC_LUT_METHOD))
      gm_UpdateAcc(UserPrefImageScheme);
#endif
      gm_UpdateColorScheme(UserPrefImageScheme);
   }
}
#endif

#ifdef Action_AdjustYUV2RGBExpansionMode_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustYUV2RGBExpansionMode(void)
//
// USAGE          : Adjusts the YUV2RGB Expansion Mode for both Main and PIP
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : gmvb_MainChannel
//                  gmvb_PipChannel
//                  St_ColorAdjust
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustYUV2RGBExpansionMode(void)
{

   if (UserPrefYUV2RGBExpansionMode == YUV2RGB_EXPANSION_LINEAR)
   {
      SelectCscMatrix(CSC_LINEAR_EXPANSION);
   }
   else if (UserPrefYUV2RGBExpansionMode == YUV2RGB_EXPANSION_PARTIAL)
   {
      SelectCscMatrix(CSC_PARTIAL_EXPANSION);
   }
   else if (UserPrefYUV2RGBExpansionMode == YUV2RGB_EXPANSION_FULL)
   {
      SelectCscMatrix(CSC_FULL_EXPANSION);
   }

   CscUpdateColors (gmvb_MainChannel);
   CscUpdateColors (gmvb_PipChannel);
}
#endif

#ifdef Action_AdjustThreeTwoFilmDisplayMode_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustThreeTwoFilmDisplayMode(void)
//
// USAGE          : Adjust the Film Display Mode control
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
//******************************************************************************
void AdjustThreeTwoFilmDisplayMode(void)
{
   //
   // The Film Mode must be in 3:2 mode
   //
   if (( gm_IsFilmModeEnabled() == TRUE ) &&
         (( UserPrefFilmMode == FM_VIDEO_32_22 ) || ( UserPrefFilmMode == FM_VIDEO_32 )))
   {
      switch ( UserPrefThreeTwoFilmDisplayMode )
      {
         case NORMAL_32_DISPLAY_MODE:   // Normal 3:2 Film mode
            {                        // it calls gm_SetFilmMode(FILM_MODE_NONE);
               gm_VideoProcessingDisable(VIDEO_2_2|VIDEO_3_3);
               break;
            }
         case FORCE_33_DISPLAY_MODE:    // Force to 3:3 Display mode
            {                        // it calls gm_SetFilmMode(FILM_MODE_3_3);
               gm_VideoProcessingDisable(VIDEO_2_2);
               gm_VideoProcessingEnable(VIDEO_3_3);
               break;
            }
         case FORCE_22_DISPLAY_MODE:    // Force to 2:2 Display mode
            {                               // it calls gm_SetFilmMode(FILM_MODE_2_2);
               gm_VideoProcessingDisable(VIDEO_3_3);
               gm_VideoProcessingEnable(VIDEO_2_2);
               break;
            }
         default:
            {
               return;
            }
      }
   }
}

//******************************************************************************
//
// FUNCTION       : BOOL IsFilmDisplayModeSupport(void)
//
// USAGE          : This function is used in the OSD WB project to check whether
//                  certain panel support "Film Display Mode".
//
// INPUT          : None
//
// OUTPUT         : TRUE - feture support
//               FALSE - not support
//
// POST_CONDITION : In order to support this feature, the parameters in
//               panel file need to be calibrated.
//                     W_22HTotal, W_33HTotal, W_22VTotal, W_33VTotal
//
//******************************************************************************
BOOL IsFilmDisplayModeSupport(void)
{
#if ((DEFAULT_PANEL == LG_WXGA_LM171W01) || (DEFAULT_PANEL == LG_WXGA_LC171W03))      // Only this panel validated
   return TRUE;
#else
   return FALSE;
#endif
}
#endif

#ifdef Action_AdjustNonACMFleshtoneCorrection_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustNonACMFleshtoneCorrection(void)
//
// USAGE          : Adjusts Non ACM Fleshtone Correction
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : FTEQ_CTRL, IMP_CONTROL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustNonACMFleshtoneCorrection(void)
{
#if (FEATURE_VIDEO_FLESHTONE == ENABLE)

   WORD W_Val=0;

   if (UserPrefNonACMFleshtoneCorrection == DISABLE)
   {
      gm_ClearRegBitsWord(FTEQ_CTRL, FTEQ_EN);
      gm_SyncUpdate(CH_A, OUTPUT_CLOCK);
   }
   else
   {
      if (gm_ReadRegWord(IMP_CONTROL) & IMP_YUV_EN)
      {
         W_Val = (FTEQ_0_TO_75_EN | (gmd_FLESHTONE_INSIDE_AND_OUTSIDE_VIDEO_WIN << 1) | FTEQ_EN);
         gm_WriteRegWord(FTEQ_CTRL,W_Val);
         gm_SyncUpdate(CH_A, OUTPUT_CLOCK);

         AdjustNonACMFleshtoneBalance();
         AdjustNonACMFleshtoneCorrectionLevel();
      }
   }
#endif
}
#endif

#ifdef Action_AdjustNonACMFleshtoneBalance_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustNonACMFleshtoneBalance(void)
//
// USAGE          : Adjusts Non ACM Fleshtone Balance
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : FTEQ_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustNonACMFleshtoneBalance(void)
{
#if (FEATURE_VIDEO_FLESHTONE == ENABLE)

   WORD W_Reg=gm_ReadRegWord(FTEQ_CTRL);
   WORD W_Val=0;

   W_Reg = W_Reg & ~(FTEQ_APERTURE);
   W_Val = ((UserPrefNonACMFleshtoneBalance << 6) & FTEQ_APERTURE);
   W_Reg = W_Reg + W_Val;
   W_Reg |= (FTEQ_0_TO_75_EN | (gmd_FLESHTONE_INSIDE_AND_OUTSIDE_VIDEO_WIN << 1));

   gm_WriteRegWord(FTEQ_CTRL, W_Reg);
   gm_SyncUpdate(CH_A, OUTPUT_CLOCK);

#endif
}
#endif

#ifdef Action_AdjustNonACMFleshtoneCorrectionLevel_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustNonACMFleshtoneCorrectionLevel(void)
//
// USAGE          : Adjusts Non ACM Fleshtone Correction Level
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : FTEQ_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustNonACMFleshtoneCorrectionLevel(void)
{
#if (FEATURE_VIDEO_FLESHTONE == ENABLE)

   WORD W_Reg=gm_ReadRegWord(FTEQ_CTRL);
   WORD W_Val=0;

   W_Reg = W_Reg & ~(FTEQ_GAIN);
   W_Val = ((UserPrefNonACMFleshtoneCorrectionLevel << 9) & FTEQ_GAIN);
   W_Reg = W_Reg + W_Val;
   W_Reg |= (FTEQ_0_TO_75_EN | (gmd_FLESHTONE_INSIDE_AND_OUTSIDE_VIDEO_WIN << 1));

   gm_WriteRegWord(FTEQ_CTRL, W_Reg);
   gm_SyncUpdate(CH_A, OUTPUT_CLOCK);

#endif
}
#endif

//******************************************************************************
//
// FUNCTION   :   void AdjustDecoderAGCMethod(void)
//
// USAGE   :   Setup Decoder Lib AGC function  based on UserPrefDecoderAGCMethod
//
// INPUT   :   None
//
// OUTPUT   :   None
//
// GLOBALS   :   None
//
// USED_REGS:   None
//
// PRE-CONDITION:   None
//
//******************************************************************************
#ifdef Action_AdjustDecoderAGCMethod_WB_Used
void AdjustDecoderAGCMethod(void)
{
//Seung-Mi: Uncomment when implemented
//   gm_SetDecoderAGCMethod( UserPrefDecoderAGCMethod );


//   debug purposes
   gmt_AGCMethod test = UserPrefDecoderAGCMethod;
   gm_Printf("UserPrefDecoderAGCMethod = %d", test);

}
#endif

//******************************************************************************
//
// FUNCTION   :   void AdjustCCSforHD(void)
//
// USAGE   :   Enable/disable CCS processing for HD input based on UserPrefCCSforHD
//
// INPUT   :   None
//
// OUTPUT   :   None
//
// GLOBALS   :   None
//
// USED_REGS:   None
//
// PRE-CONDITION:   None
//
//******************************************************************************
#ifdef Action_AdjustCCSforHD_WB_Used
void AdjustCCSforHD(void)
{
#if (FEATURE_CCS == ENABLE)
   if (IsCCSforHDDisabled())
      gm_VideoProcessingAdjustment(VIDEO_CCS, CCS_OFF);
#endif
}
#endif

//******************************************************************************
//
// FUNCTION   :   void AdjustTwoStageProcessing(void)
//
// USAGE   :   Enable/disable 2 stage/2 pass processing. This feature should be on whenever there
//                  is a full-screen Main with no PIP. Durinig the transition from two-stage processing to
//                  normal, the screen is blanked.
//
// INPUT   :   None
//
// OUTPUT   :   None
//
// GLOBALS   :   None
//
// USED_REGS:   None
//
// PRE-CONDITION:   None
//
//******************************************************************************
#ifdef Action_AdjustTwoStageProcessing_WB_Used
void AdjustTwoStageProcessing(void)
{
#if (FEATURE_TWO_STAGE_PROCESSING_MODE == ENABLE)
   if (!gm_Is2StageEnabled() && IsTwoStageAllowed()
         && (UserPrefPipMode == NO_PIP))
   {
      EnterTwoStageProcessing();
      ModeSetupBlender(CH_A, DISPLAY_DEFER_TMO_NORMAL);
   }
   else if (gm_Is2StageEnabled())
   {
      ExitTwoStageProcessing();
      ModeSetupBlender(CH_A, DISPLAY_DEFER_TMO_NORMAL);
      ModeSetupBlender(CH_B, DISPLAY_DEFER_TMO_NORMAL);
   }
#endif
}
#endif


//******************************************************************************
//
// FUNCTION   :   void CC_Process(void)
//
// USAGE   :   Process CC till there is no more data
//
// INPUT   :   None
//
// OUTPUT   :   None
//
// GLOBALS   :   None
//
// USED_REGS:   None
//
// PRE-CONDITION:   None
//
//******************************************************************************
void CC_Process(void)
{
}

//******************************************************************************
//
// FUNCTION   :   void SetSharpnessNoiseCoringToTNR(void)
//
// USAGE   :
//
// INPUT   :   None
//
// OUTPUT   :   None
//
// GLOBALS   :   None
//
// USED_REGS:   None
//
// PRE-CONDITION:   None
//
//******************************************************************************
#ifdef Action_SetSharpnessNoiseCoringToTNR_WB_Used
void SetSharpnessNoiseCoringToTNR(void)
{
#if (FEATURE_VIDEO_SHARPNOISE == REV2)
   if (gm_IsVideo(CH_A) == TRUE)
   {
      // UserPrefTNR should have been updated prior to calling this function
      switch (UserPrefTNR)
      {
         case TNR_ADAPTIVE:
            UserPrefSharpNoise = SHARPNOISE_ADAPTIVE;
            break;
         case TNR_LOW:
            UserPrefSharpNoise = SHARPNOISE_LOW;
            break;
         case TNR_MEDIUM:
            UserPrefSharpNoise = SHARPNOISE_MEDIUM;
            break;
         case TNR_HIGH:
         case TNR_SUPER_HIGH:
            UserPrefSharpNoise = SHARPNOISE_HIGH;
            break;
         case TNR_OFF:
         default:
            UserPrefSharpNoise = SHARPNOISE_OFF;
      }
      gm_VideoProcessingAdjustment(VIDEO_SHARPNOISE, UserPrefSharpNoise);
   }
#endif
}
#endif




#ifdef Action_AdjustReg_MHF_ENH_Y_LSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_LSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_LSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_LSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_LSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MHF_ENH_Y_LOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MHF_ENH_Y_LUSHOOT_TOL);

   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1& ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_LSHOOT_TOL);

   W_Reg2 = (W_Reg2& ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_LSHOOT_TOL);


   gm_WriteRegWord(MHF_ENH_Y_LOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MHF_ENH_Y_LUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);

#endif


}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_SSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_SSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_SSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_SSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_SSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MHF_ENH_Y_SOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MHF_ENH_Y_SUSHOOT_TOL);

   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_SSHOOT_TOL);

   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_SSHOOT_TOL);

   gm_WriteRegWord(MHF_ENH_Y_SOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MHF_ENH_Y_SUSHOOT_TOL, W_Reg2);
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_LGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_LGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_LGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_LGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_LGAIN(void)
{
// (FEATURE_SHARPNESS == REV5)
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_SGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_SGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_SGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_SGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_SGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_SGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_SGAIN);
   gm_WriteRegWord(MHF_ENH_Y_SGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_FINALSGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_FINALSGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_FINALSGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_FINALSGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_FINALSGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_FINALSGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_FINALSGAIN);
   gm_WriteRegWord(MHF_ENH_Y_FINALSGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_FINALLGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_FINALLGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_FINALLGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_FINALLGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_FINALLGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_FINALLGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_FINALLGAIN);
   gm_WriteRegWord(MHF_ENH_Y_FINALLGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_FINALGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_FINALGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_FINALGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_FINALGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_FINALGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_FINALGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_FINALGAIN);
   gm_WriteRegWord(MHF_ENH_Y_FINALGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_DELTA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_DELTA(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_DELTA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_DELTA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_DELTA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_DELTA);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_Y_DELTA);
   gm_WriteRegWord(MHF_ENH_Y_DELTA, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_SLOPE_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_SLOPE(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_SLOPE
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_SLOPE
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_SLOPE(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_SLOPE);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_Y_SLOPE);
   gm_WriteRegWord(MHF_ENH_Y_SLOPE, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_THRESH(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_THRESH);
   // bit masking to BIT0_TO_BIT11
   W_Reg = (W_Reg & ~BIT0_TO_BIT11) +
           (BIT0_TO_BIT11 & UserPrefReg_MHF_ENH_Y_THRESH);
   gm_WriteRegWord(MHF_ENH_Y_THRESH, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_HIGH_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_HIGH_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_HIGH_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_HIGH_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_HIGH_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_HIGH_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_Y_HIGH_SLOPE_AGC);
   gm_WriteRegWord(MHF_ENH_Y_HIGH_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_LOW_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_LOW_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_LOW_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_LOW_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_LOW_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_LOW_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_Y_LOW_SLOPE_AGC);
   gm_WriteRegWord(MHF_ENH_Y_LOW_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_HIGH_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_HIGH_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_HIGH_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_HIGH_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_HIGH_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_HIGH_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_HIGH_THRESH_AGC);
   gm_WriteRegWord(MHF_ENH_Y_HIGH_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_Y_LOW_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_Y_LOW_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_Y_LOW_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_Y_LOW_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_Y_LOW_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_Y_LOW_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_Y_LOW_THRESH_AGC);
   gm_WriteRegWord(MHF_ENH_Y_LOW_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_LSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_LSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_LSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_LSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_LSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MHF_ENH_UV_LOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MHF_ENH_UV_LUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_LSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_LSHOOT_TOL);
   gm_WriteRegWord(MHF_ENH_UV_LOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MHF_ENH_UV_LUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_SSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_SSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_SSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_SSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_SSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MHF_ENH_UV_SOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MHF_ENH_UV_SUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_SSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_SSHOOT_TOL);
   gm_WriteRegWord(MHF_ENH_UV_SOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MHF_ENH_UV_SUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_LGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_LGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_LGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_LGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_LGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_LGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_LGAIN);
   gm_WriteRegWord(MHF_ENH_UV_LGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_SGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_SGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_SGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_SGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_SGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_SGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_SGAIN);
   gm_WriteRegWord(MHF_ENH_UV_SGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_FINALSGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_FINALSGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_FINALSGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_FINALSGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_FINALSGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_FINALSGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_FINALSGAIN);
   gm_WriteRegWord(MHF_ENH_UV_FINALSGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_FINALLGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_FINALLGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_FINALLGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_FINALLGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_FINALLGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_FINALLGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_FINALLGAIN);
   gm_WriteRegWord(MHF_ENH_UV_FINALLGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_FINALGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_FINALGAIN(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_FINALGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_FINALGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_FINALGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_FINALGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_FINALGAIN);
   gm_WriteRegWord(MHF_ENH_UV_FINALGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_DELTA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_DELTA(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_DELTA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_DELTA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_DELTA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_DELTA);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_UV_DELTA);
   gm_WriteRegWord(MHF_ENH_UV_DELTA, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_SLOPE_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_SLOPE(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_SLOPE
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_SLOPE
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_SLOPE(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_SLOPE);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_UV_SLOPE);
   gm_WriteRegWord(MHF_ENH_UV_SLOPE, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_THRESH(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_THRESH);
   // bit masking to BIT0_TO_BIT11
   W_Reg = (W_Reg & ~BIT0_TO_BIT11) +
           (BIT0_TO_BIT11 & UserPrefReg_MHF_ENH_UV_THRESH);
   gm_WriteRegWord(MHF_ENH_UV_THRESH, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_HIGH_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_HIGH_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_HIGH_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_HIGH_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_HIGH_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_HIGH_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_UV_HIGH_SLOPE_AGC);
   gm_WriteRegWord(MHF_ENH_UV_HIGH_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_LOW_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_LOW_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_LOW_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_LOW_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_LOW_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_LOW_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MHF_ENH_UV_LOW_SLOPE_AGC);
   gm_WriteRegWord(MHF_ENH_UV_LOW_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_HIGH_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_HIGH_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_HIGH_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_HIGH_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_HIGH_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_HIGH_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_HIGH_THRESH_AGC);
   gm_WriteRegWord(MHF_ENH_UV_HIGH_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MHF_ENH_UV_LOW_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MHF_ENH_UV_LOW_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MHF_ENH_UV_LOW_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_ENH_UV_LOW_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MHF_ENH_UV_LOW_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MHF_ENH_UV_LOW_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MHF_ENH_UV_LOW_THRESH_AGC);
   gm_WriteRegWord(MHF_ENH_UV_LOW_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_LSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_LSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_LSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_LSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_LSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MVF_ENH_Y_LOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MVF_ENH_Y_LUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_LSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_LSHOOT_TOL);
   gm_WriteRegWord(MVF_ENH_Y_LOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MVF_ENH_Y_LUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_SSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_SSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_SSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_SSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_SSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MVF_ENH_Y_SOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MVF_ENH_Y_SUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_SSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_SSHOOT_TOL);
   gm_WriteRegWord(MVF_ENH_Y_SOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MVF_ENH_Y_SUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif


#ifdef Action_AdjustReg_MVF_ENH_Y_LGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_LGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_LGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_LGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_LGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_LGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_LGAIN);
   gm_WriteRegWord(MVF_ENH_Y_LGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_SGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_SGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_SGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_SGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_SGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_SGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_SGAIN);
   gm_WriteRegWord(MVF_ENH_Y_SGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_FINALSGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_FINALSGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_FINALSGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_FINALSGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_FINALSGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_FINALSGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_FINALSGAIN);
   gm_WriteRegWord(MVF_ENH_Y_FINALSGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_FINALLGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_FINALLGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_FINALLGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_FINALLGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_FINALLGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_FINALLGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_FINALLGAIN);
   gm_WriteRegWord(MVF_ENH_Y_FINALLGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_FINALGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_FINALGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_FINALGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_FINALGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_FINALGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_FINALGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_FINALGAIN);
   gm_WriteRegWord(MVF_ENH_Y_FINALGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_DELTA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_DELTA(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_DELTA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_DELTA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_DELTA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_DELTA);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_Y_DELTA);
   gm_WriteRegWord(MVF_ENH_Y_DELTA, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_SLOPE_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_SLOPE(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_SLOPE
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_SLOPE
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_SLOPE(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_SLOPE);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_Y_SLOPE);
   gm_WriteRegWord(MVF_ENH_Y_SLOPE, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_THRESH(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_THRESH);
   // bit masking to BIT0_TO_BIT11
   W_Reg = (W_Reg & ~BIT0_TO_BIT11) +
           (BIT0_TO_BIT11 & UserPrefReg_MVF_ENH_Y_THRESH);
   gm_WriteRegWord(MVF_ENH_Y_THRESH, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_HIGH_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_HIGH_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_HIGH_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_HIGH_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_HIGH_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_HIGH_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_Y_HIGH_SLOPE_AGC);
   gm_WriteRegWord(MVF_ENH_Y_HIGH_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_LOW_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_LOW_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_LOW_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_LOW_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_LOW_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_LOW_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_Y_LOW_SLOPE_AGC);
   gm_WriteRegWord(MVF_ENH_Y_LOW_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_HIGH_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_HIGH_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_HIGH_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_HIGH_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_HIGH_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_Y_HIGH_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_Y_HIGH_THRESH_AGC);
   gm_WriteRegWord(MVF_ENH_Y_HIGH_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_Y_LOW_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_Y_LOW_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_Y_LOW_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_Y_LOW_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_Y_LOW_THRESH_AGC(void)
{
// (FEATURE_SHARPNESS == REV5)
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_LSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_LSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_LSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_LSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_LSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MVF_ENH_UV_LOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MVF_ENH_UV_LUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_LSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_LSHOOT_TOL);
   gm_WriteRegWord(MVF_ENH_UV_LOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MVF_ENH_UV_LUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_SSHOOT_TOL_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_SSHOOT_TOL(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_SSHOOT_TOL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_SSHOOT_TOL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_SSHOOT_TOL(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg1 = gm_ReadRegWord(MVF_ENH_UV_SOSHOOT_TOL);
   WORD W_Reg2 = gm_ReadRegWord(MVF_ENH_UV_SUSHOOT_TOL);
   // bit masking to BIT0_TO_BIT9
   W_Reg1 = (W_Reg1 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_SSHOOT_TOL);
   W_Reg2 = (W_Reg2 & ~BIT0_TO_BIT9) +
            (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_SSHOOT_TOL);
   gm_WriteRegWord(MVF_ENH_UV_SOSHOOT_TOL, W_Reg1 );
   gm_WriteRegWord(MVF_ENH_UV_SUSHOOT_TOL, W_Reg2 );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_LGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_LGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_LGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_LGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_LGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_LGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_LGAIN);
   gm_WriteRegWord(MVF_ENH_UV_LGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_SGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_SGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_SGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_SGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_SGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_SGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_SGAIN);
   gm_WriteRegWord(MVF_ENH_UV_SGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_FINALSGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_FINALSGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_FINALSGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_FINALSGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_FINALSGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_FINALSGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_FINALSGAIN);
   gm_WriteRegWord(MVF_ENH_UV_FINALSGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_FINALLGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_FINALLGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_FINALLGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_FINALLGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_FINALLGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_FINALLGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_FINALLGAIN);
   gm_WriteRegWord(MVF_ENH_UV_FINALLGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_FINALGAIN_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_FINALGAIN(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_FINALGAIN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_FINALGAIN
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_FINALGAIN(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_FINALGAIN);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_FINALGAIN);
   gm_WriteRegWord(MVF_ENH_UV_FINALGAIN, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_DELTA_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_DELTA(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_DELTA
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_DELTA
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_DELTA(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_DELTA);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_UV_DELTA);
   gm_WriteRegWord(MVF_ENH_UV_DELTA, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_SLOPE_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_SLOPE(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_SLOPE
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_SLOPE
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_SLOPE(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_SLOPE);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_UV_SLOPE);
   gm_WriteRegWord(MVF_ENH_UV_SLOPE, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_THRESH_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_THRESH(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_THRESH
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_THRESH
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_THRESH(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_THRESH);
   // bit masking to BIT0_TO_BIT11
   W_Reg = (W_Reg & ~BIT0_TO_BIT11) +
           (BIT0_TO_BIT11 & UserPrefReg_MVF_ENH_UV_THRESH);
   gm_WriteRegWord(MVF_ENH_UV_THRESH, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_HIGH_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_HIGH_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_HIGH_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_HIGH_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_HIGH_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_HIGH_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_UV_HIGH_SLOPE_AGC);
   gm_WriteRegWord(MVF_ENH_UV_HIGH_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_LOW_SLOPE_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_LOW_SLOPE_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_LOW_SLOPE_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_LOW_SLOPE_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_LOW_SLOPE_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_LOW_SLOPE_AGC);
   // bit masking to BIT0_TO_BIT5
   W_Reg = (W_Reg & ~BIT0_TO_BIT5) +
           (BIT0_TO_BIT5 & UserPrefReg_MVF_ENH_UV_LOW_SLOPE_AGC);
   gm_WriteRegWord(MVF_ENH_UV_LOW_SLOPE_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_HIGH_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_HIGH_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_HIGH_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_HIGH_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_HIGH_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_HIGH_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_HIGH_THRESH_AGC);
   gm_WriteRegWord(MVF_ENH_UV_HIGH_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustReg_MVF_ENH_UV_LOW_THRESH_AGC_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustReg_MVF_ENH_UV_LOW_THRESH_AGC(void)
//
// USAGE          : Write UserPref to MVF_ENH_UV_LOW_THRESH_AGC
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MVF_ENH_UV_LOW_THRESH_AGC
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustReg_MVF_ENH_UV_LOW_THRESH_AGC(void)
{
#if (FEATURE_SHARPNESS == REV6)
   WORD W_Reg = gm_ReadRegWord(MVF_ENH_UV_LOW_THRESH_AGC);
   // bit masking to BIT0_TO_BIT9
   W_Reg = (W_Reg & ~BIT0_TO_BIT9) +
           (BIT0_TO_BIT9 & UserPrefReg_MVF_ENH_UV_LOW_THRESH_AGC);
   gm_WriteRegWord(MVF_ENH_UV_LOW_THRESH_AGC, W_Reg );
   gm_SyncUpdate(CH_A, INPUT_OUTPUT_CLOCK);
#endif
}
#endif



#ifdef Action_AdjustEnhancerEnable_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustEnhancerEnable(void)
//
// USAGE          : Write UserPref to MHF_ENH_EN and MVF_ENH_EN
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : MHF_CTRL, MVF_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustEnhancerEnable(void)
{
#if (FEATURE_SHARPNESS == REV6)
#ifdef UserPrefEnhancerEnable
   gm_EnhancerEnable(UserPrefEnhancerEnable);
#endif
#endif
}
#endif



#ifdef Action_AdjustOldEnhancerEnable_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustOldEnhancerEnable(void)
//
// USAGE          : Write UserPref to ENH_ENABLE
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : ENH_CTRL
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustOldEnhancerEnable(void)
{
   /*
   #ifdef UserPrefOldEnhancerEnable
   gm_OldEnhancerEnable(UserPrefOldEnhancerEnable);
   #endif
   */
}
#endif



#ifdef Action_AdjustOldEnhancerRouting_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustOldEnhancerRouting(void)
//
// USAGE          : Write UserPref to EDGE_ENH_RESOURCE_SEL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : EDGE_ENH_RESOURCE_SEL (in ODP_CTRL)
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustOldEnhancerRouting(void)
{
#if (FEATURE_CROSS_POINT_SWITCH == ENABLE)
#ifdef UserPrefOldEnhancerRouting
   gmt_PHY_CH B_Channel = (UserPrefOldEnhancerRouting == 0)?CH_A:CH_B;

   // ODP_CTRL is removed.
   //gm_OldEnhancerRouting(UserPrefOldEnhancerRouting == 0);// zero means Main; one means Pip

   // gm_SetScalerSharpness() depends on correct setting of the bit ODP_CTRL[EDGE_ENH_RESOURCE_SEL] by gm_OldEnhancerRouting()
   if (gm_TimingIsStable(B_Channel))
   {
      if (gm_IsGraphics(B_Channel))
         gm_SetScalerSharpness(B_Channel, (B_Channel==gmvb_MainChannel)?UserPrefSharpnessRGB:UserPrefSharpnessRGBpip);
      else
         gm_SetScalerSharpness(B_Channel, (B_Channel==gmvb_MainChannel)?UserPrefSharpness:UserPrefSharpnessPip);
   }
#endif
#endif
}
#endif

#ifdef Action_AdjustColorResourceRouting_WB_Used
//******************************************************************************
//
// FUNCTION       : void AdjustColorResourceRouting(void)
//
// USAGE          : Write UserPref to COLOR_RESOURCE_SEL
//
// INPUT          : None
//
// OUTPUT         : None
//
// GLOBALS        : None
//
// USED_REGS      : COLOR_RESOURCE_SEL (in ODP_CTRL)
//
// PRE_CONDITION  : None
//
// POST_CONDITION :
//
//******************************************************************************
void AdjustColorResourceRouting(void)
{
#if (FEATURE_CROSS_POINT_SWITCH == ENABLE)
#ifdef UserPrefColorResourceRouting
   gm_ColorResourceRouting(UserPrefColorResourceRouting == 0);// zero means Main; one means Pip
#endif
   SetupColorSpace(CH_A);
   SetupColorSpace(CH_B);
#endif
}
#endif

//******************************************************************************
//
// FUNCTION       : Bool AllowNewEnhancers(void)
//
// USAGE          : Returns true if new (Sequoia) enhancer menus are allowed
//
// INPUT          : None
//
// OUTPUT         : True if new enhancer menus allowed (is a Sequoia chip)
//
// GLOBALS        : FEATURE_SHARPNESS
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION : None
//
//******************************************************************************
BOOL AllowNewEnhancers(void)
{
#if (FEATURE_SHARPNESS == REV6)
   return TRUE;
#else
   return FALSE;
#endif
}


//******************************************************************************
//
// FUNCTION       : BOOL OldEnhancerEnableChangedByUser(bool inValue)
//
// USAGE          : Returns true if the OldEnhancerEnable has been changed by the user
//
// INPUT          : Byte value, 1, 2, or other, sets the function to return true afterward
//
// OUTPUT         : Returns true if the OldEnhancerEnable has been changed by the user (previous
//                        value of 1, then value of 2).  This corresponds with a user changing the pref
//                        in the button, then exiting that button.  Only if that sequence occurs will
//                        the value in this function be set up to return true.
//
// GLOBALS        : None
//
// USED_REGS      : None
//
// PRE_CONDITION  : None
//
// POST_CONDITION : None
//
//******************************************************************************
BOOL OldEnhancerEnableChangedByUser(BYTE inValue)
{
   static BYTE wasChangedByUser = 0;

   if (inValue == 1)
   {
      wasChangedByUser = 1;
   }

   if ((inValue == 2)&&(wasChangedByUser==1))
   {
      wasChangedByUser = 2;
   }
   else
   {
      wasChangedByUser = 0;
   }

   if (wasChangedByUser == 2)
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}


//*********************************  END  **************************************
